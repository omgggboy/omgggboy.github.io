{"meta":{"title":"猪猪侠","subtitle":"做一只想飞的猪","description":"一个猪窝","author":"Jiaxi Zhang","url":"https://shen-yu.gitee.io","root":"/"},"pages":[{"title":"about","date":"2020-03-06T12:45:58.000Z","updated":"2020-07-25T09:01:07.234Z","comments":true,"path":"about/index.html","permalink":"https://shen-yu.gitee.io/about/index.html","excerpt":"","text":"A Coder, Live in Hangzhou, China 姓名：张嘉喜现居：杭州github：omgggboyQQ：171496079微信：m171496079————————————————————————————浙江大学软件工程硕士在读，硕士一年级。目前在浙江大学计算机辅助设计与图形学(cad&amp;cg)国家重点实验室主要研究数据可视化c++精通，qml精通，计算机图像学入门 目前主要进行电力展示沙盘项目的开发，该项目已经被部分省份使用，正在不断迭代更新。 博客拿来记录学习和分享生活，欢迎交流"},{"title":"categories","date":"2020-03-06T12:46:38.000Z","updated":"2020-03-06T12:58:13.714Z","comments":true,"path":"categories/index.html","permalink":"https://shen-yu.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-06T12:46:12.000Z","updated":"2020-03-06T12:59:06.971Z","comments":true,"path":"tags/index.html","permalink":"https://shen-yu.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-06T12:46:23.000Z","updated":"2020-03-06T12:46:23.862Z","comments":true,"path":"friends/index.html","permalink":"https://shen-yu.gitee.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"雷火引擎一面二面","slug":"interview_163_leihuo","date":"2020-08-13T06:00:00.000Z","updated":"2020-08-14T15:05:23.556Z","comments":true,"path":"2020/ckdud69gi000r369kcl788349/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gi000r369kcl788349/","excerpt":"","text":"前言参加完OpenDay热血澎湃。早上网易mini游戏展，堪比ChinaJoy的模式，就是比较小型。但是整个游戏来说大部分可能还是Demon的形式，但是总体制作还是比较精良的。有一种参加学校社团展示的感觉，每个人都很热血。下午，动作捕捉中心和lua编写AI脚本。体验拉满。第二天刚好面试，还沉浸OpenDay的欢乐之中。 一面手写了五道题目主要考察虚函数，数学知识和算法 10个数二分查找失败查找几次 入射方向L, 法线N，求反射R 哪些可以是虚函数 虚函数 左值右值 排序算法有哪些 归并排序怎么实现，主要思想 反问面试官 询问了雷火的主要产品和收益情况？主要收益来自逆水寒和倩女幽魂 询问了unity和unreal的学习问题？unity容易上手，unreal上手相对会难一点。 二面是昨天mini项目的导师 自我介绍 看到我也学了GAMES101，询问GAMES101学到了什么，和别的有什么不同 考察两个数学题 ，光线反射， 给定一个点和面求交点 询问项目，想查看项目的具体展示，项目的实际问题，解决方案 询问了笔试时小王打字那个题目 动态规划的基本思想 简单手写了前序遍历 反问面试官 引擎的各种子系统会有哪些？推荐了《游戏引擎架构》，可以作为扫盲书。 举例了雷火主要使用unity，腾讯主要使用unreal,推荐去自己熟悉操作一下引擎，尝试跑一些例子。 好心建议就是离引擎的水平还是有一定差距，客户端还是可以继续三面，主要看你个人意愿。我现在做的就是我自己热爱的东西。所以。。。。公司相对会更愿意招一个能掌握最近资讯和技术的人，节约了培养成本。 后记整体感觉都很好，面试交流也比较融洽，在面试的过程中还是能学到很多东西，如果学习路线该怎么走，履历该怎么增加等等，面试官无疑是最好的学习指导，以为他知道他想要什么，你就从他想要的东西里看看自己缺少什么。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"网易互联网笔试","slug":"exam_163_internet","date":"2020-08-08T06:00:00.000Z","updated":"2020-08-12T15:07:29.851Z","comments":true,"path":"2020/ckdud69ga000a369k7vpmfzdu/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69ga000a369k7vpmfzdu/","excerpt":"","text":"前言中午被麻辣香锅搞得死去活来，下午被网易笔试搞得死去活来。四道题AC1.25,第三题没看，第四题是强连通量，关于图的题目是我的薄弱，得去花些时间看看。 第一题 回文串给定一个长度为n(n&lt;=1e3)的字符串，可以在后面加无限多的字母，问能组成的最短回文串是多长？解法一：注意到n比较小，直接暴力解法二：可以用manachar算法，算出原串最长回文后缀的长度，然后就可以得到最短的字符串了。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;bool check(string &amp;s, int start, int end) &#123; int i = start, j = end; while (i &lt; j &amp;&amp; s[i] == s[j]) &#123; ++i, --j; &#125; return i &gt;= j;&#125;int main() &#123; string s; cin &gt;&gt; s; int length = s.size(); for (int i = 0; i &lt; length; ++i) &#123; if (check(s, i, length - 1)) &#123; break; &#125; &#125; string prefix = s.substr(0, i); reverse(prefix.begin(), prefix.end()); cout &lt;&lt; s + prefix &lt;&lt; endl; return 0;&#125; 第二题 物品价值现在有n个物品，每个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人分到的物品价值总和相同(个数可以不同，总价值相同即可)，剩下的物品就要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。输入： 第一行输入一个整数T，代表有T组测试数据 对于每一组测试数据，一行输入一个整数n，代表物品的个数 接下来n个数，a[i]代表每一个物品的价值 1 &lt;= T &lt;= 10 1 &lt;= n &lt;= 15 1 &lt;= a[i] &lt;= 100000输出： 每一行输出最少需要扔掉多少价值的物品 示例：输入1530 60 5 15 30输出20 说明样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每个人分到的价值为60，扔掉的价值为20。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int siz=1500000;int a[20],dp[siz+5];int main()&#123; int T, n, i, j, ans, sum; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; sum = 0; for (i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (i = 0; i &lt; n; ++i)&#123; for (j = sum; j &gt;= a[i]; --j) dp[j] = dp[j] | dp[j-a[i]]; &#125; ans = sum; for (i = sum; i &gt;= 0; --i) &#123; if( i % 2 != 0) continue; if(dp[i] &amp;&amp; dp[i/2]) &#123; ans = sum - i; break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 第三题 排队买票题目描述n(n&lt;=2000)个人排队买票，第i个人要么单独买票，要么和后面一个人一起买（反过来，就是可以和前面一个人买），单独买花费时间a[i]，一起买是b[i]，求所有人买完票的最短时间。开始时间是早上08:00:00 am，输出结束时间。 分析动态规划，dp[i]表示第i个人买完票所需要的时间。对于每一个人他可以有两个选择，要么单独买票，那么需要的总的时间就是dp[i-1] + a[i]，要么和前一个人一起买票，需要的总的时间就是dp[i-2] + b[i]。最后输出的时候注意格式。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int a[2222], b[2222];int dp[2222];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n; ++i) cin &gt;&gt; a[i]; for (int i = 2; i &lt;= n; ++i) cin &gt;&gt; b[i]; memset(dp, 0, sizeof(dp)); dp[0] = 0, dp[1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = min(dp[i - 1] + a[i], dp[i - 2] + b[i]); &#125; int hour = dp[n] / 3600 + 8; int minutes = dp[n] % 3600 / 60; int seconds = dp[n] % 3600 % 60; printf(\"%02d:%02d:%02d \", hour, minutes, seconds); puts(hour &lt;= 12 ? \"am\" : \"pm\"); return 0;&#125; 第四题 相互认可题目描述a教授认可b教授，b教授认可c教授，那么a也认可c。现有n (小于50000)个教授，m（小于600000）个认可，可能自己认可自己，也可能重复。求互相认可的教授有多少对？分析学过强联通分量的应该可以一下子看出来这个就是要求强联通分量，每个强联通分量里的所有教授都是互相认可的。。没学过的话可以尝试暴力解解。 思考如果改变下条件，只要a认可b，那么b就默认认可a，这个时候求互相认可的教授有多少对该怎么算呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 555;#define ll long longint low[maxn], num[maxn], dfn, cnt;ll ans;int sccno[maxn];stack&lt;int&gt; st;vector&lt;int&gt; G[maxn];void dfs(int u) &#123; st.push(u); low[u] = num[u] = ++dfn; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if (!num[v])&#123; dfs(v); low[u] = min(low[u], low[v]); &#125; else if (!sccno[v]) &#123; low[u] = min(low[u], num[v]); &#125; &#125; if (low[u] == num[u]) &#123; cnt++; int tmp = 0; while(true) &#123; int v = st.top(); st.pop(); tmp++; sccno[v] = cnt; if (u == v) break; &#125; ans += tmp * (tmp - 1) / 2; &#125;&#125;void tarjan(int n) &#123; cnt = dfn = 0; ans = 0; memset(sccno, 0, sizeof(sccno)); memset(low, 0, sizeof(low)); memset(num, 0, sizeof(num)); for (int i = 1; i &lt;= n; ++i) &#123; if (!num[i]) dfs(i); &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); &#125; tarjan(n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记可能还是得多花些时间在刷题上，在这参加的四五次笔试中,目标还是得冲击AC3.0 4AC可能有点难， 下次可能还是得自己找四道题，然后花2小时看看能做多少。 内容部分摘抄自公众号：https://mp.weixin.qq.com/s?__biz=MzI5MDA4ODczOA==&amp;mid=2648028133&amp;idx=1&amp;sn=4c819b2b17cb50aa40855468f7e2ef88&amp;chksm=f40421a8c373a8bed46bad37341a5c7b9c0f8c5a1d441774b3cfdfd6c5d9fe7bba213605c31c&amp;scene=158#rd","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"网易互娱图形开发工程师sp","slug":"interview_163_huyu","date":"2020-08-04T06:00:00.000Z","updated":"2020-08-05T04:42:26.562Z","comments":true,"path":"2020/ckdud69gg000n369kexao7x7c/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gg000n369kexao7x7c/","excerpt":"","text":"前言在面试之前，特地去网易互娱校招官网查看了图形开发工程师的职位描述和要求。 以下复制一下 职位要求 1234567891011121314您可以：- 负责游戏产品的视觉效果，实现各种酷炫的效果，让所有平台和设备的玩家都有同样震撼的游戏体验；- 负责游戏产品的图形部分相关开发； - 与美术协作实现各种高级视觉效果，并优化content pipeline。任职资格我们希望您具备以下条件：- 计算机视觉或图形学等相关研究方向；- 有扎实的c++基础；- 有良好的图形学和数学基础；- 至少熟悉DirectX、OpenGL、Metal或者Vulkan中的一种图形API，并有很强的shader编写能力；- 熟悉AAA级游戏中常见的渲染技术，并对某一领域有深入理解，比如全局光照、粒子、材质表现、性能优化；- 有一定debug和性能分析能力。备注：广州需求80，杭州需求15，上海需求25。 当看到熟悉AAA级游戏中的渲染技术，对某一领域有深入理解。内心就频频发虚。看了看杭州需求15人，基本也没有我的什么机会了。但是，面试就是抱试试水的心态，一探虚实。 预约14：30面试，可能是面试官来不及安排，所以安排我们手撕了一道简单的算法题。 试前代码题目：区间合并（leetcode 56题原题）给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].示例2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-intervals著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解（自己花了15分钟写出来，这里复制官方题解，清晰明了方便日后学习）12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if (intervals.size() == 0) &#123; return &#123;&#125;; &#125; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; merged; for (int i = 0; i &lt; intervals.size(); ++i) &#123; int L = intervals[i][0], R = intervals[i][1]; if (!merged.size() || merged.back()[1] &lt; L) &#123; merged.push_back(&#123;L, R&#125;); &#125; else &#123; merged.back()[1] = max(merged.back()[1], R); &#125; &#125; return merged; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 面试刷完笔试题后，15分钟看着电脑屏幕里的自己，不敢玩手机，怕被误认为作弊，也不管浏览网页，就这样傻傻的看着自己。 15：00面试官来了。 相比较字节和华为的面试官，网易的这位面试官发量明显稀少了很多。 开篇：先做个简单的自我介绍，知识点考察主要分为c++和图形学相关知识 c++ 你知道程序由于异常退出，导致资源无法释放。这样的问题有什么解决方案么？（主要考察智能指针） 由智能指针出发询问你是否知道RAII？ 考察了为什么要引入move new和molloc的区别 vector和list遍历一遍谁比较快 map和unordered_map的区别和使用场景 你对多线程有了解么 虚函数的考察：构造函数调用虚函数 字节面试官也问了(https://blog.csdn.net/songchuwang1868/article/details/96481853) 图形学 这个渲染管线的流程 顶点着色器完成了什么 光栅化完成了什么 混合和测试完成了什么 用于加速光线追踪的算法 阴影的算法 描述一个算法如何实现只将你看到的内容加载，没看到的内容就不加载 回马枪笔试考察了一下纸牌排序random_shuffle, 查了一下这个是stl的内部函数 12345678910template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt; void random_shuffle (RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; gen)&#123; iterator_traits&lt;RandomAccessIterator&gt;::difference_type i, n; n = (last-first); for (i=n-1; i&gt;0; --i) &#123; swap (first[i],first[gen(i+1)]); &#125;&#125; 反问面试官 询问了RAII的意思 询问了图形开发工程师和引擎开发工程师， 图形可能会更偏向渲染这一块， 引擎更偏向物理引擎这一块。 后记GAMES101更偏向讲rendering偏向图形开发， GAMES201更偏向讲物理引擎和数值计算偏向与引擎。但是GAMES201难度比GAMES101高多了，有时间还是得去复习一下GAMES101的内容如果想面试图形开发工程师的话，当然，多线程编程也需要去学习和弄个小项目自己玩玩。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"网易雷火游戏研发笔试","slug":"exam_163","date":"2020-08-02T06:00:00.000Z","updated":"2020-08-03T13:01:25.538Z","comments":true,"path":"2020/ckdud69g50005369k0fbz8gn3/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69g50005369k0fbz8gn3/","excerpt":"","text":"前言最近，可能是投的岗位有点多，所以就收到各种笔试和面试通知，静下心来准备面试的时间开始变得琐碎了。对于具体的职业发展方向开始有点踌躇。无论选择哪个方向都是还有一堆的东西等着你去补。对于网易3个小时的笔试，4道编程题，时间依旧是十分紧张。在上次阿里笔试看了别的大佬AC的代码简洁清晰，这可能就是和那些ACMer的差距，比较人家的代码量是你的几十倍。网易还有一个特别的地方就是不允许使用本地IDE。四道题的题目分值不同，分别是10，20，30，40。总分100。 第一题 完全二叉树的翻转 10分输入n, mn表示完全二叉树的层数m表示需要进行翻转的节点翻转：该节点的左右子树进行交换 输入 输出 1 1 /\\ /\\ 2 3 2 3 /\\ /\\ /\\ /\\ 4 5 6 7 4 5 7 6 /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ 8 9 10 11 12 13 14 15 8 9 10 11 14 15 12 13 输入：4 3输出：123457689101114151213 题解(AC)12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public:// 递归也可以用队列来代替， 递归写法简单，在时间通过的情况下可以选择递归 void dfs(vector&lt;int&gt; &amp;arr, int left, int right) &#123; if (left &gt; arr.size() - 1 || right &gt; arr.size() - 1) &#123; return; &#125; else &#123; // 左边遍历左子树， 右边遍历右子树 dfs(arr, 2 * left, 2 * right); dfs(arr, 2 * left + 1, 2 * right + 1); swap(arr[left], arr[right]); &#125; return; &#125;&#125;;int main() &#123; Solution s = Solution(); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int size = 1 &lt;&lt; n; vector&lt;int&gt; arr(size, -1); for (int i = 1; i &lt; size; i++) &#123; arr[i] = i; &#125; s.dfs(arr, 2 * m, 2 * m + 1); for (int i = 1; i &lt; size; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 第二题 福袋问题（20分）第一行输入N，K，其中N代表有多少种商品,K代表每个福袋要包含K种不同的物品。第二行输入N个整数表示，每种商品的数量 要求输出最多能凑成多少个福袋。输入：5 31 2 3 4 5输出：5商品组合： 商品1 商品2 商品3 商品4 商品5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 共计A1 B:2 C:3 D:4 E:5 题解 (AC 90%, 具体对一些N和K的限制条件忘了)12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, k; while (cin &gt;&gt; n &gt;&gt; k) &#123; vector&lt;int&gt; arr(n, -1); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ans = 0; sort(arr.begin(), arr.end());// 商品不足K则结束 while (arr[n - k]) &#123; ans += arr[n - k]; for (int i = 1; i &lt;= k; i++) &#123; arr[n - i] -= arr[n - k]; &#125; sort(arr.begin(), arr.end()); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 第三题 打字问题 (30分)输入N，N表示需要打的字数，输出 打出至少N个字，需要的最少按键数。 基本操作：操作1： X：没有选中内容，在当前位置输入X，如有选中内容，替换选中内容为X。按键数为1。操作2： CTRL + A :选中全部内容。按键数为2。操作3： CTRL + C :更新粘贴板的内容为选中内容， 初始时粘贴板为空。按键数为2。操作4: CTRL + V :复制粘贴板的内容输出。按键数为2。操作5： ESC:取消当前选中状态。按键数为1 输入;100 输出：29 操作 键数 字数 X 7键 7 CTRL + A 9键 7 CTRL + C 11键 7 ESC 12键 7 CTRL + V 14键 14 CTRL + V 16键 21 CTRL + V 18键 28 CTRL + A 20键 28 CTRL + C 22键 28 ESC 23键 28 CTRL + V 25键 56 CTRL + V 27键 84 CTRL + V 29键 112 思路①第一种情况在输入了i个字符的基础上，再输入10-i个，(i为从1到9)； ②第二种情况：输入了i个字符后，我复制这i个字符，取消选择，然后在后面进行多次粘贴，这里的i可以从1到10/2；循环取i，求最小值，需要注意的是，当10%i不为0时，需要再加上F(10%i)； ③第三种情况：输入了i个字符后，我还是复制粘贴这i个字符，但是上面②是复制之后，取消选择，在原来的后面继续粘贴；这里我复制之后，输入一个字符，将原来输入的都覆盖掉，然后再粘贴；题解 (选自牛客ShareLe https://blog.nowcoder.net/n/d43c430ce1434432862efc6f05513fbf)12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N; while (cin &gt;&gt; N) &#123; vector&lt;int&gt; dp(N + 1, 99999); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) dp[i] = min(dp[i], dp[i - j] + j); //情况① for (int j = 1; j &lt;= i / 2; j++) &#123; dp[i] = min(dp[i], dp[j] + i / j * 2 + 3 + dp[i%j]); //情况② dp[i] = min(dp[i], dp[j] + i / j * 2 + 5); //情况③ &#125; &#125; cout &lt;&lt; dp[N] &lt;&lt; endl; &#125; return 0;&#125; 第四题 开心消消乐 (40分)输入一个m,n m表示行数， n表示列数， 输入一串数字，从左到右，从上到下填充，随后还有一串数字，表示缓冲队列Q消除规则;同一行或者同一列有三个相同的数字则消除输入：6 4 123657133245111998578392 123456输出126657 输入 置零 下降 填充 置零 填充 123657 023657 000657 123657 120657 126657 133245 033245 023245 423245 420245 420245 111998 000998 033998 533998 530998 530998 578392 578392 578392 578392 578392 578392 题解（自己写的代码写完没来得及调试时间就到了，所以此处引用一个类似题目的代码，日后有时间再来修改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//// main.cpp// huawei//// Created by SteveWong on 11/10/2016.// Copyright © 2016 SteveWong. All rights reserved.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;ctime&gt;//#include &lt;cstdlib&gt;using namespace std;const int LEN = 8;void pmap(int map[][LEN])&#123; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; cout &lt;&lt; map[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;// 检查以(i,j)为中心的点, 看是否可以消除bool check(int map[][LEN], int i, int j)// 保证i、j不越界,&#123; if ( (i - 1 &gt;= 0 &amp;&amp; i + 1 &lt; LEN &amp;&amp; map[i - 1][j] == map[i][j] &amp;&amp; map[i][j] == map[i + 1][j]) || (j - 1 &gt;= 0 &amp;&amp; j + 1 &lt; LEN &amp;&amp; map[i][j - 1] == map[i][j] &amp;&amp; map[i][j] == map[i][j + 1]) || (i - 2 &gt;= 0 &amp;&amp; map[i - 2][j] == map[i - 1][j] &amp;&amp; map[i - 1][j] == map[i][j]) || (j - 2 &gt;= 0 &amp;&amp; map[i][j - 2] == map[i][j - 1] &amp;&amp; map[i][j - 1] == map[i][j]) || (i + 2 &lt; LEN &amp;&amp; map[i + 2][j] == map[i + 1][j] &amp;&amp; map[i + 1][j] == map[i][j]) || (j + 2 &lt; LEN &amp;&amp; map[i][j + 2] == map[i][j + 1] &amp;&amp; map[i][j + 1] == map[i][j]) ) &#123; return true; &#125; return false;&#125;bool swapAndJudge(int m[][LEN], int i, int j)// 保证i、j不越界, 应该对被swap的两个点都做纵向和横向的检查&#123; int map[LEN][LEN]; for (int ii = 0; ii &lt; LEN; ++ii) &#123; for (int jj = 0; jj &lt; LEN; ++jj) &#123; map[ii][jj] = m[ii][jj]; &#125; &#125; // 原来就可以消除 if (check(map, i, j)) &#123; printf(\"no need to swap at (%d, %d)\\n\", i, j); return true; &#125; // 只需要向下换和向右换 // 向下换 if (i + 1 &lt; LEN) &#123; swap(map[i + 1][j], map[i][j]); if (check(map, i, j)) &#123; printf(\"# swap and sweap! (%d, %d)\\n\", i, j); return true; &#125; if (check(map, i + 1, j)) &#123; printf(\"# swap and sweap! (%d, %d)\\n\", i + 1, j); return true; &#125; swap(map[i + 1][j], map[i][j]);// 换回来 &#125; // 向右换 if (j + 1 &lt; LEN) &#123; swap(map[i][j + 1], map[i][j]); if (check(map, i, j)) &#123; printf(\"# swap and sweap! (%d, %d)\\n\", i, j); return true; &#125; if (check(map, i, j + 1)) &#123; printf(\"# swap and sweap! (%d, %d)\\n\", i, j + 1); return true; &#125; swap(map[i][j + 1], map[i][j]);// 换回来 &#125; return false;&#125;void findMinSwap(int map[][LEN])&#123; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; if (swapAndJudge(map, i, j)) &#123; printf(\"gotcha! (%d, %d)\\n\", i, j); &#125; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; srand(unsigned(time(0))); int p[LEN][LEN]; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; p[i][j] = rand() % 10; &#125; &#125; cout &lt;&lt; \"xiaoxiaole!\\n\"; findMinSwap(p); pmap(p); system(\"pause\"); return 0;&#125; 后记每次考试都是意犹未尽的感觉，还是有很多完善的地方，很多知识点还得多练习。刷题目前可能将近100道，还是得多刷多码。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"拼多多ios客户端笔试","slug":"exam_pdd","date":"2020-08-02T06:00:00.000Z","updated":"2020-08-04T04:39:42.173Z","comments":true,"path":"2020/ckdud69gd000g369kd9mc272p/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gd000g369kd9mc272p/","excerpt":"","text":"前言这半年一直再做客户端，但是我们的客户端与实际大厂的客户端，又不尽相同。客户端可以分为ios，Android，windows，mac等，ios主要要求Object-C和Swift, Android主要用Java。Windows和Mac可能要求C++。所以就项目基础来说去做Windows下的客户端可能会有一定优势，看了这多岗位，感觉字节的C++ 客户端研发工程师-抖音/火山直播这个是比较接近的。当然还有游戏客户端，游戏客户端往往还要求你熟悉一门脚本语言，因为纯c++的游戏，马上就会被外挂搞得毫无游戏体验，脚本的加密，让外挂的制作难度提升了一个档次。除此之外，还会要求你有主流游戏引擎的操作经验，图形学接口的熟悉，shader的编写能力等等。相比华为的宽泛要求，这些细致的要求让你忘而却步。现在的主流市场已经往移动端发展，那么在主机上制作客户端的岗位又会渐渐缩水。ios客户端和Android客户端相比较而言更加吃香。 如果继续学习C++，去华为阿里这样的地方做底层开发，操作系统内核，数据库可能是比较好的处理。还有就是做游戏，计算机图形学的相关内容。现在准备java去达到一个面试水平，应该是比较难的。所以现阶段，应该还是好好看看操作系统，数据库相关内容的书籍。图形学和游戏引擎的熟悉可能稍微滞后一些，感觉相对而言会比较没那么快上手。简单做个fps游戏，作为简历上的闪光点，当然也是一个值得考虑的事情。 前一段时间已经投了五六家大厂，接下来的半个月应该稍微静下心来，继续准备，先不投一段时间，因为接踵而至的笔试和面试，会让你喘不过气，每天都处于这个没面好，那个没考好的焦虑当中。 第一题 单项选择 (5道)主要考察OBJECT-C的内容 一个比较关键的字眼就是KVC。 KVC（Key-value coding）键值编码，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。 作者：jackyshan链接：https://www.jianshu.com/p/b9f020a8b4c9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第二题 多项选择（5道）主要印象就是涉及到资源池资源释放什么的知识点，因为对ios一窍不通，所以就连题目也记不住了。 第三题 飞行棋 (25分)输入第一行 输入K，N，K表示距离终端的距离，N表示丢骰子的次数第二行 输入N个数 表示每次丢骰子的点数大小。输出 如果在N步之前到达终点则打印”paradox”否则输入 距离终点的距离，和回退的次数。两个数自间用空格隔开。回退就是飞行棋一样到终点多了的就往回走。 例：输入：10 36 6 6输出：4 2 坑点就是这个N步之前阻止了很多人AC。 题解（AC 100%）123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int k, n; while (cin &gt;&gt; k &gt;&gt; n) &#123; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; int tmp; cin &gt;&gt; tmp; k -= tmp; // 回退 if (k &lt; 0) &#123; k = -k; cnt++; &#125; // N步之前到达终点 else if (k == 0 &amp;&amp; i != n - 1) &#123; cout &lt;&lt; \"paradox\" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 第四题 相同的骰子 (25分)输入N N表示输入骰子的个数随后输入N个骰子，每个数字顺序上下左右前后。输出第一行输出有多少个不同的骰子第二行输出每种骰子的个数 例：输入：2123456625314 输出：21 1 思路这道题没找到题解，讲讲思路吧，我定义了三个函数对骰子做变换，三个自由度，每个自由度可以动0-3下，然后做比较。这个算法的时间复杂度分析。变换与比较的时间是常数C,每加入一个骰子都与前面N-1个骰子比较。估算时间复杂度为o(N^2);这算是暴力解法，AC应该是AC不了。 第五题 吃饭问题 (25分)输入：第一行输入M,N,T M表示午餐的套餐数，N表示晚餐的套餐数,T表示最要要达到的美味值随后M行输入Xi, Yi, Xi表示热量值， Yi表示美味值随后N行输入Xj, Yj, Xj表示热量值， Yj表示美味值输出：求在满足美味值的前提下，最少摄入的热量。可以选择不吃饭或者只吃一顿饭，一顿饭只能吃一种套餐。如果达不到美味值，输出-1 例子：输入3 1 84 33 58 92 5输出6 题解（自己写了个N^2的算法只能AC40%，这个是别人AC94%的代码）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667作者：澹台棋晴链接：https://www.nowcoder.com/discuss/465070?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=-2&amp;source_id=search_all来源：牛客网#include &lt;bits/stdc++.h&gt;#include \"iostream\"#include \"vector\"#include \"algorithm\"using namespace std; int N,M,T;bool cmp(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b)&#123; return a.first&gt;b.first;&#125;int main() &#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;T; int x,y; int maxYlunch=0,maxYdinner=0; vector&lt;pair&lt;int,int&gt;&gt;lunch; vector&lt;pair&lt;int,int&gt;&gt;dinner; while(N--)&#123; cin&gt;&gt;x&gt;&gt;y; lunch.push_back(make_pair(y,x)); maxYlunch = max(maxYlunch,y); &#125; while(M--)&#123; cin&gt;&gt;x&gt;&gt;y; dinner.push_back(make_pair(y,x)); maxYdinner = max(maxYdinner,y); //cout&lt;&lt;\" sdfsdfsd\"&lt;&lt;endl; &#125; //cout&lt;&lt;maxYdinner&lt;&lt;\" \"&lt;&lt;maxYlunch&lt;&lt;\" \"&lt;&lt;T; if((maxYlunch+maxYdinner)&lt;T)&#123; cout&lt;&lt;-1&lt;&lt;\" \"; return 0; &#125; sort(lunch.begin(),lunch.end()); sort(dinner.begin(),dinner.end(),cmp);//从小到大排序否则超时了 //cout&lt;&lt;\" sdfsdfsd1\"&lt;&lt;endl; int fat=100000; for(int i=0;i&lt;lunch.size();i++)&#123; //cout&lt;&lt;lunch.size()&lt;&lt;\" \"; //cout&lt;&lt;\" sdfsdfsd2\"&lt;&lt;endl; if(lunch[i].first&gt;=T)&#123; fat = min(fat,lunch[i].second); continue; &#125; for(int j=0;j&lt;dinner.size();j++)&#123; if((lunch[i].first + dinner[j].first)&gt;=T)&#123; fat = min(fat,lunch[i].second+dinner[j].second); &#125; else&#123; break;//排序为了节省时间的，后边的都小，不满足条件，直接跳出就可以 &#125; &#125; &#125; for(int i=0;i&lt;dinner.size();i++) &#123; if (dinner[i].first &gt;= T) &#123; fat = min(fat, dinner[i].second); &#125; &#125; cout&lt;&lt;fat&lt;&lt;\" \"; return 0;&#125;","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"7.31 阿里笔试","slug":"exam_ALBB","date":"2020-07-31T06:00:00.000Z","updated":"2020-07-31T16:04:31.871Z","comments":true,"path":"2020/ckdud69g60006369kag2ieupt/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69g60006369kag2ieupt/","excerpt":"","text":"前言一小时两道题， 吃完晚饭就整装待发准备做了，还是有点紧张的。想要做出一道就勉强混过去。 第一题 带牛去吃草多少种组合方式小明带着n头牛 有m种颜色，每头牛都是互异的。小明带任意头牛出去吃草。请问有多少种组合？种类太多 取模 1e9+71&lt;= n &lt;= 1e9, 1&lt;= m &lt;= 1e9 例：输入：3， 2 输出27 举例带0头 1带1头 3 * 2带2头 3 * 2 * 2带3头 1 * 2 * 2 * 21 + 6 + 12 + 8 = 27 自己猜测的题解我当时看到这个就想到杨辉三角,当时没过，我当时忘了取模1e9但是不知道自己思路是否正确，因为我当时没思路就跳到第二题了。 12345678910#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123; long long n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; cout &lt;&lt; (long long) pow(m + 1, n) % 1e9 &lt;&lt; endl; &#125;&#125; 第二题 迷宫中的最短路径第一行输入，n,m,p 在（1，500）之间随后输入n行m长度的字符串 C代表陆地， S代表海洋随后p行按照bx, by, ex, eybx,by代表起点 ex,ey代表终点 输出起点到终点所需要最少体力 移动规则：只能上下左右四个方向，陆地到陆地消耗3体力，海洋到海洋消耗2体力，海洋到陆地或陆地到海洋消耗5体力， 输入：4 4 2CCCSSSSSCSCSSSCC1 1 4 33 1 1 3 输出：1314 事后多花了半小时调通的题解没机会扔进去测试一下对不对了。 感觉自己蛮代码的速度好慢呀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;queue&gt;using namespace std;int xr[4] = &#123;1, -1, 0, 0&#125;;int yr[4] = &#123;0, 0, 1, -1&#125;;int n, m ,p;bool inMat(int x, int y) &#123; return x&gt;=0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;vector&lt;vector&lt;int&gt;&gt; bfs(int bx, int by, vector&lt;string&gt; &amp;mat) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(m , 0x3f3f3f)); q.push(make_pair(bx, by)); res[bx][by] = 0; while(!q.empty()) &#123; pair&lt;int, int&gt; tmp = q.front(); q.pop(); int tx = tmp.first, ty = tmp.second; for(int i = 0; i &lt; 4 ;i ++) &#123; //判断是否在界内 if(inMat(tx+xr[i], ty + yr[i])) &#123; if(mat[tx][ty] == mat[tx + xr[i]][ty+yr[i]]) &#123; if(mat[tx][ty] == 'C') &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 3) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 3; &#125; else &#123; //无更新， 跳过 continue; &#125; &#125; if(mat[tx][ty] == 'S') &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 2) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 2; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 5) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 5; &#125; else &#123; continue; &#125; &#125; //有更新，进队 q.push(make_pair(tx+xr[i], ty + yr[i])); &#125; &#125; &#125; return res;&#125;int main(int argc, const char * argv[]) &#123; //cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; n = 4; m = 4; p = 2; //vector&lt;string&gt; mat(n, \"\"); vector&lt;string&gt; mat; mat.push_back(\"CCCS\"); mat.push_back(\"SSSS\"); mat.push_back(\"CSCS\"); mat.push_back(\"SSCC\");// for(int i = 0; i &lt; n; i++) &#123;// cin &gt;&gt; mat[i];// &#125;// vector&lt;vector&lt;int&gt;&gt; be(p,vector&lt;int&gt;(4, 0) );// for(int i = 0; i &lt; p; i++) &#123;// for(int j = 0 ; j &lt; 4; j++) &#123;// cin &gt;&gt; be[i][j];// &#125;// &#125; vector&lt;vector&lt;int&gt;&gt; be = &#123;&#123;1, 1, 4, 3&#125;, &#123;3, 1, 1, 3&#125;&#125;; for(int i = 0 ; i &lt; p; i++) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , 0x3f3f3f)); // 题目中列为x， 行为y dp = bfs(be[i][1] - 1, be[i][0] - 1, mat); int ex = be[i][3], ey = be[i][2]; cout &lt;&lt; dp[ex - 1][ey - 1]&lt;&lt; endl; &#125; return 0;&#125; 后记这次笔试我两道题都是0， 不知道会不会连面试的机会都没有， 每道题的题解也不知道对不对，有没有参加了并AC的大佬来指点一下迷津。刷题还得刷呀，code速度太慢了，思路没那么清晰，都是码一点想一点。我好菜呀，阿里好难。 抄袭一下AC的答案第一题123456789101112131415161718192021222324252627作者：zyx_xiao链接：https://www.nowcoder.com/discuss/464106?type=0&amp;order=0&amp;pos=7&amp;page=1&amp;channel=666&amp;source_id=discuss_tag来源：牛客网#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll ;ll n, m;ll powmod(ll x,ll n ,ll mod)&#123; ll res=1; while(n&gt;0) &#123; if(n&amp;1LL) res=res*x%mod ; x=x*x%mod; n&gt;&gt;=1; &#125; return res ;&#125;int main()&#123; ll mod = 1000000007; scanf(\"%lld %lld\", &amp;n, &amp;m); m++; printf(\"%lld\\n\", powmod(m, n, mod)); return 0;&#125; 第二题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253作者：zyx_xiao链接：https://www.nowcoder.com/discuss/464106?type=0&amp;order=0&amp;pos=7&amp;page=1&amp;channel=666&amp;source_id=discuss_tag来源：牛客网#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, q;char mp[505][505];int vis[505][505];int dx[4] = &#123;0,0,1,-1&#125;;int dy[4] = &#123;1,-1,0,0&#125;;int bx,by,ex,ey;struct node&#123; int x,y; node(int xx,int yy):x(xx),y(yy)&#123;&#125;&#125;;int main()&#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q); for(int i = 0 ; i &lt; n ; i++) scanf(\"%s\", mp[i]); while(q--)&#123; for(int i = 0 ; i &lt; n ; i++) for(int j = 0 ; j &lt; m ; j++) vis[i][j] = 10000000; scanf(\"%d %d %d %d\", &amp;bx, &amp;by, &amp;ex, &amp;ey); bx--;by--;ex--;ey--; vis[bx][by] = 0; queue&lt;node&gt; que; que.push(node(bx, by)); while(!que.empty())&#123; node t = que.front(); que.pop(); for(int i = 0 ; i &lt; 4 ; i++)&#123; int x = t.x + dx[i]; int y = t.y + dy[i]; if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m) continue; int w = 5; if(mp[x][y]==mp[t.x][t.y])&#123; if(mp[x][y]=='C') w = 3; else w = 2; &#125; if(vis[x][y] &lt;= vis[t.x][t.y]+w) continue; vis[x][y] = vis[t.x][t.y] + w; que.push(node(x,y)); &#125; &#125; printf(\"%d\\n\", vis[ex][ey]); &#125; return 0;&#125;","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"华为提前批综合面试","slug":"interview_HW_3","date":"2020-07-30T06:00:00.000Z","updated":"2020-07-30T15:19:07.032Z","comments":true,"path":"2020/ckdud69gl0010369kg1fo9kfq/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gl0010369kg1fo9kfq/","excerpt":"","text":"前言开始很紧张，面试前巨害怕。会不会和自己昨晚在网上搜索的内容一样有相似的经历。然后，又不得不请个假。面试前面试官不能录屏。然后又反复进入，留我一个人在视频里。这次面试没有像前两次一样一上来就手撕代码。（我前两次都没能撕出来）。主要的面试内容就是看着你的简历向你提问。 面试要点 询问了本科和研究生的绩点 询问了本科和研究生的主要课程 询问课程在实际生活是否有应用，在哪里 询问了软件开发的完整流程 询问了个人的优缺点，分别在哪里体现 询问了为什么选择进入软件开发 周末喜欢做什么 询问了个人对地域选择的意愿 询问了学长学姐的主要去向 询问了个人对薪资的期望 反问面试官 你能给我介绍一下杭州的主要业务？华为的四大BG，软件研究院里面主要做研究的。杭州定位为计算研究所。华为开源的各种底层服务，open欧拉 open罗庚等等。 如果我进入计算产品线，需要具备哪些计算栈？主要强力推荐了《计算机体系结构》。 后记隔天，查看官网的招聘进度，已经显示通过，并且询问了在职学长，说明已经进入池子了。等待被打捞，收获第一个offer。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为软件开发工程师提前批二面","slug":"interview_HW2","date":"2020-07-28T04:33:28.944Z","updated":"2020-07-28T04:33:28.944Z","comments":true,"path":"2020/ckdud69gj000t369k0x8958yf/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gj000t369k0x8958yf/","excerpt":"","text":"前言一个电话没接着，打不回去，就好怕改时间还是自己错过了。打校招电话回去咨询。还请教了一面的面试官。不过最后还是完美收尾了 手写代码进来先考察代码能力，这次题目是leetcode316原题，因为没刷到过，而且本身对回溯的算法还不是很熟，所以没能在规定时间内，完成这道题目。后面参考答案后写出的解题： 1234567891011121314class Solution &#123;public: string removeDuplicateLetters(string s) &#123; string str; for(size_t i = 0; i &lt; s.size(); i++) &#123; if(str.find(s[i]) != string::npos) continue; while(!str.empty() &amp;&amp; str.back() &gt; s[i] &amp;&amp; s.find(str.back(), i)!=string::npos) str.pop_back(); str.push_back(s[i]); &#125; return str; &#125;&#125;; 贪心加栈，同时，当根据条件去掉一个栈顶元素时，新的栈顶元素可能也大于当前元素，所以应该继续判断新的栈顶元素和当前元素的关系，用一个while循环，直到出现一个不满足循环条件的栈顶元素（要么小于当前元素，要么大于当前元素但后续又无与之相同的元素来替代）。 剩下进去问答环节1.考察了设计模式2.考察了面向对象的三个特点3.考察了stl和红黑树4.考察了C++虚函数5.询问了项目相关6.考察了模版类7.考察了软件工程相关的整个流程8.考察了类的六大特性9.new和molloc的区别10.构造函数和析构函数的调用过程11.介绍一下继承的种类 我询问面试官软件工程的知识在实际开发过程中真的会用到么会用到很多，对于整个过程管理会很严格，文档和单元测试，集成测试等环节。 后记感觉整个面试还是很不错，但是不知道会不会有三面，好想拿到offer！","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为软件开发工程师提前批一面","slug":"interview_HW_1","date":"2020-07-26T08:04:28.466Z","updated":"2020-07-26T08:04:28.466Z","comments":true,"path":"2020/ckdud69gn0018369khc5u3t7f/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gn0018369khc5u3t7f/","excerpt":"","text":"前言紧张激动，不知所措。面对一个大黑幕，但是看着自己就好像没有看着字节面试官那时候紧张了。 手写代码进来先考察代码能力，这次题目是leetcode40原题，因为没刷到过，而且本身对回溯的算法还不是很熟，所以没能在规定时间内，完成这道题目。后面参考答案后写出的解题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// main.cpp// test_HW//// Created by 张嘉喜 on 2020/7/24.// Copyright © 2020 张嘉喜. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; candidates; vector&lt;int&gt; path;public: void DFS(int start, int target) &#123; if(target == 0) &#123; ans.push_back(path); return; &#125; for(int i = start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0 ; i++) &#123; //剪枝去重 //这里i &gt; start 放在前面不然有些编译器会提示数组越界了 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); DFS(i + 1, target - candidates[i]); // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; // 排序后方便剪枝 sort(candidates.begin(), candidates.end()); this-&gt;candidates = candidates; DFS(0, target); return ans; &#125;&#125;;int main(int argc, const char * argv[]) &#123; vector&lt;int&gt; candidates ; candidates.push_back(10); candidates.push_back(1); candidates.push_back(2); candidates.push_back(7); candidates.push_back(6); candidates.push_back(1); candidates.push_back(5); Solution s = Solution(); vector&lt;vector&lt;int&gt;&gt; ans = s.combinationSum2(candidates, 8); for(int i = 0 ; i &lt; ans.size(); i++) &#123; for(int j = 0 ; j &lt; ans[i].size(); j++ ) &#123; cout &lt;&lt; ans[i][j] &lt;&lt; endl; &#125; &#125; return 0;&#125; 对于回溯和剪枝的题目还是作太少了。应该要加强练习。 剩下进去问答环节1.查看了我leetcode的刷题情况，询问我主要擅长什么类型的题目，能否独立完成困难题目。2.询问了是否知道回溯。3.考察了DFS和BFS，原理和实现，应用场景4.考察了C++虚函数5.能讲解一下类吗6.询问了项目相关7.询问是否对数据库底层原理了解8.学习能力怎么样 我询问面试官准备秋招还有哪些方面1.继续刷题，笔试500分会重点关注。要了解更多的算法思想，并查集，回溯，递归，递推，归并，贪心，动态规划，模拟，枚举2.熟悉操作系统，因为杭研所主要还是做底层开发的，所以对整个CPU执行程序的过程，汇编等需要用到3.如果有兴趣来做数据库的话，也要需要了解数据库相关的底层原理 后记和面试官整个沟通过程，感觉整个状态很好，所以也如愿以偿收到二面通知，明天就要二面了。加油～","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为笔试总结","slug":"exam_HW","date":"2020-07-23T06:00:00.000Z","updated":"2020-07-25T09:19:20.252Z","comments":true,"path":"2020/ckdud69gb000b369kgg15d1h5/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gb000b369kgg15d1h5/","excerpt":"","text":"前言中午预约的机考时间，记错成了第二天晚上才开始。结果，晚上7点多和朋友过生日的时候，收到了短信，提醒考试已经开始快半小时了。赶紧跑了回来。内心一百只草泥马飞过。总体而言就算给我更多的时间不一定思路就清晰了。 1.求余数给定两个数，将两个数的各位求和在求余数。例如：输入：123 11 输出：0 （1+2+3）%（1+1） = 6%2 = 0； 题解 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int solution(long long m, long long n) &#123; int am = 0, an = 0; while(m) &#123; am += m % 10; m /= 10; &#125; while(n) &#123; an += n % 10; n /= 10; &#125; return am % an;&#125;int main() &#123; // 怕数字范围溢出， 得回去记一下每个数据类型的表示范围。 long long m, n; // 牛客对于简单的测试需要循环输入。 while(cin &gt;&gt; m &gt;&gt; n) cout &lt;&lt; solution(m, n) &lt;&lt; endl; return 0;&#125; 这道题画了没几分钟，主要用来适应环境的。 2. 买最少的东西有五件商品，价格分别是1，3，7，11，13.给定的钱，和各商品数量，然后购买最少商品的数量， 务必将钱花完。例如：输入：1 2 3 4 530输出：4 2 * 13 + 1 * 3 + 1 * 1 = 30；2 + 1 + 1 = 4； 题解 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using pii = pair&lt;int, int&gt;;#define X first#define Y secondvector&lt;int&gt; price = &#123;1,3,7,11,13&#125;;int main() &#123; int V; vector&lt;pii&gt; packs; for(int i = 0 ; i &lt; 5; i++)&#123; int cnt, k = 1; cin &gt;&gt; cnt; while(cnt &gt; k)&#123; //混合背包转01背包 packs.push_back(&#123;k, k * price[i]&#125;); cnt -= k; k *= 2; &#125; if(cnt) packs.push_back(&#123;cnt, cnt * price[i]&#125;); &#125; cin &gt;&gt; V; vector&lt;int&gt; dp(V + 1, 0x3f3f3f);//dp[i],花费i，数量最少 dp[0] = 0; for(auto&amp; pack: packs) &#123; for(int j = V; j &gt;= pack.Y; --j) &#123; dp[j] = min(dp[j], dp[j - pack.Y] + pack.X); &#125; &#125; cout &lt;&lt; dp[V]; return 0;&#125; 3. 给定距离的不同走法给定距离，并给出各种步长，nums[0]…num[n -1],请问有多少种走法（不考虑走路的顺序）先走短的再走长的，步长互异。 例如：输入：41 2 输出：31+1+1+1 = 41+1+2 = 4；2+2 = 4题解 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(int n, vector&lt;int&gt; &amp; num) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for(int i = 0; i &lt; num.size(); i++)&#123; for(int j = num[i]; j &lt;= n; j++) &#123; dp[j] += dp[j - num[i]]; &#125; &#125; return dp[n];&#125;int main() &#123; int n; vector&lt;int&gt; num; cin &gt;&gt; n; int temp; // 这里不能想牛客那样推出， 我就定义输入零结束输入 while(cin &gt;&gt; temp) &#123; if(!temp) break; num.push_back(temp); &#125; sort(num.begin(), num.end()); cout &lt;&lt; solution(n, num)&lt;&lt;endl; return 0;&#125; 总结后面两个解答都是参考了牛客博主xinxin1000的答案，还附赠了背包问题学习大礼包https://anivian.github.io/pack-master/V2.pdf超级感谢这位来自清华的小姐姐。希望明天面试顺利～～～～","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"进程间通信","slug":"Interprocess_communication","date":"2020-07-14T06:00:00.000Z","updated":"2020-07-25T09:17:59.758Z","comments":true,"path":"2020/ckdud69g40004369k0uzr6l98/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69g40004369k0uzr6l98/","excerpt":"","text":"进程协作的目的 信息共享： 由于多用户可能对同样的信息感兴趣（例如共享文件），所以应提供环境以允许并发访问这些信息。 计算加速： 如果希望一个特定快速运行，那么应将系统功能划分成子任务，而每个子任务可以与其他子任务一起并行执行。注意，如果要实现这样的加速，那么计算机需要有多个处理核。 模块化： 可以需要按模块化方式构造系统，如第2章所讨论的，可将系统功能划分成独立的进程和线程。 方便： 即使单个用户也可以同时执行许多任务。例如，用户可以并行的编辑、收听音乐、编译。 协作进程需要进程间通信（IPC)进程间通信的两种基本模型：共享内存和消息传递共享内存系统采用共享内存的进程间通信，需要通信进程建立共享内存区域。通常，一片共享内存区域驻留在创建共享内存段的进程空间内。其他希望使用这个共享内存段进行通信段进行通信的进程应将其附加到自己的地址空间。 生产者进程生成信息，以供消费者进程消费。为了允许生存者进程和消费者进程并发执行，应有一个可用的缓冲区，以被生存者填充和被消费者清空。这个缓冲区驻留在生产者进程和消费者进程的共享内存区域内。当消费者使用一项时，生产者可生产另一项。生产者和消费者必须同步，这样消费者不会试图消费一个尚未生产出来的项。 缓冲区域类型可分为两种。无界缓冲区没有限制缓冲区的大小。消费者可能不得不等待新的项，但生产者总是可以产生新项。有界缓冲区假设固定大小的缓冲区。对于这种情况，如果缓冲区空，那么消费者必须等待；并且如果缓冲区满，那么生产者必须等待。 采用共享内存的生产者进程如下：123456789while(true) &#123; &#x2F;* produce an item in next_produced *&#x2F; while(((in + 1) % BUFFER_SIZE) &#x3D;&#x3D; out) ; &#x2F;* do nothing *&#x2F; buffer[in] &#x3D; next_produced; in &#x3D; (in + 1) % BUFFER_SIZE;&#125; 采用共享内存的消费者进程如下：12345678while(true) &#123; while(in &#x3D;&#x3D; out) ;&#x2F;* do nothing *&#x2F; next_consumed &#x3D; buffer[out]; out &#x3D; (out + 1) % BUFFER_SIZE; &#x2F;* consume the item in next_consumed *&#x2F;&#125; 消息传递系统对于分布式环境（通信进程可能位于通过网络连接的不同计算机），消息传递特别有用。消息传递工具提供至少两种操作： send(message) recevie(message) 进程发送消息可以是定长的或变长的。如果只能发生定长消息，那么系统级实现就简单。不过，这一限制使得编程任务更加困难。相反，变长消息要求更复杂的系统级实现，但是编程任务就变得更简单。在整个操作系统设计中，这种折中很常见。 如果进程P和Q需要通信，那么它们必须相互发送消息和接受消息：它们之间要有通信链路。该链路的实现有多种方法。这里不关心链路的物理实现，而只关心链路的逻辑实现。这里有几个方法，用于实现链路和操作send()/receive(): 直接或间接的通信 同步或异步的通信 自动或显式的缓冲 1. 命名需要通信的进程应有一个方法，以便相互引用。它们可以直接或间接的通信。对于直接通信，需要通信的每个进程必须指明指定通信的接收者或发送者。采用这种方案，原语send()和receive()定义如下： send(P, message): 向进程P发送message。 receive(Q, message)： 从进程Q接收message。 这种方案的通信链路具有以下属性： 在需要通信的每对进程之间，自动建立链路。进程仅需知道对方身份就可交流。 每个链路只与两个进程相关。 每个进程只有一个链路。 这种方案展示了寻址的对称性，即发送和接收进程必须指定对方，以便通信。这种方案的一个变形采用寻址的非对称性，即只要发送者指定接收者，而接受者不需要指定发送者。采用这种方案，原语send()和receive()的定义如下： send(P, message): 向进程P发送message。 receive(id, message): 从任何进程，接收message，这里变量id被设置成与其通信进程的名称。 这两个方案（对称和非对称的寻址）的缺点是：生成进程定义的有限模块化。更改进程的标志符可能需要分析其他进程定义。所有旧的标志符的引用都应找到，以便修改成为新标识符。通常，任何时候的硬编码技术（其中标志符需要明确指定），与下面所诉的采用间接技术相比要差。 在间接通信中，通过邮箱和端口来接收消息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一的标识符。一个进程可以通过不同邮箱与另一个进程通信，但是两个进程只有拥有一个共享邮箱时才能通信。原语send()和receive()定义如下： send(A, message): 向邮箱A发送message。 receive(A, message): 从邮箱A接收messgae。 对于这种方案，链路通信具有如下特点： 只有两个进程共享一个邮箱时，才能建立通信链路。 一个链路可以与两个或更多进程相关联。 两个通信进程之间可有多个不同链路，每个链路对应于一个邮箱。 2. 同步进程间通信可以通过调用原语send()和receive()来进行。实现这些原语有不同的设计方案。消息传递可以是阻塞或非阻塞，也称为同步或异步。 阻塞发送： 发送进程阻塞，直到消息由接收进程或邮箱所接收。 非阻塞发送： 发送进程发送消息，并且恢复操作。 阻塞接收： 接收进程阻塞，直到消息可用。 非阻塞接收： 接收进程收到一个有效消息或者空消息。 不同组合的send()和receive()都有可能。当send()和receive()都是阻塞的，则在发送者和接收者之间就有一个交互。当采用阻塞的send()和receive()时，生产者-消费者问题的解决就简单了。生产者仅需调用阻塞send()并且等待，直到消息被送到接收者或者邮箱。同样，当消费者调用reiceve()时，它会阻塞直到有一个消息可用。 采用消息传递的生产者进程如下：123456message next_producedwhile(true) &#123; &#x2F;* produce an item in next_produced *&#x2F; send(next_produced);&#125; 采用消息传递的消费者进程如下：123456message next_comsumedwhile(true) &#123; receive(next_consumed); &#x2F;* consume the item in next_consumed *&#x2F;&#125; 3. 缓存不管通信时直接的还是间接的，通信进程交换的消息总是驻留在临时队列中。简单地讲，队列实现有三种方法： 零容量：队列的最大长度为0；因此，链路中不能有任何消息处于等待。对于这种情况，发送者应阻塞，直到接收者接收消息。 有限容量： 队列长度为有限的n；因此，最多只能有n个消息驻留其中。如果在发送消失时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发生者可以继续执行而不必等待。然而，链路容量是有限。如果链路已满，那么发送者应阻塞，直到队列空间有有用的为止。 无限容量： 队列长度可以无限，因此，不管多少消息都可以在其中等待。发送者从不阻塞。 零容量情况称为无缓冲的消息系统，其他情况称为自动缓冲的消息系统。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"字节跳动秋招提前批c++客户端一面","slug":"interview_ByteDance","date":"2020-07-06T06:00:00.000Z","updated":"2020-07-25T09:18:16.217Z","comments":true,"path":"2020/ckdud69gf000m369k1g0hdrx2/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gf000m369k1g0hdrx2/","excerpt":"","text":"内心独白算是第一次正式的视频面试，还是很紧张……( ´▽｀)； 过程总结 简短的自我介绍 询问项目相关 QML和QWeight比较，当初项目为什么选用这个 OpenGL版本 QT的信号与槽， 可以用什么代替 进程间通信方式，线程间通信方式 c++面向对象的三个特性具体解释一下 关于一段代码的虚函数调用后结果 关于虚函数表的问题 反思感觉对于图形学实际学习还存在欠缺，对于操作系统和C++语言深入了解不够细致，只是懂个大概，实际应用能力还有待增长。QT相关的应用也应该更加深入了解。查漏补缺吧。对于一面提及到的知识点回去好好温习巩固一下。只是提前批的第一波，不知道后面的公司有没有音讯，继续学习。期待能有二面吧，目前还是很想去字节上班的。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"动态库与静态库的区别","slug":"libvdll","date":"2020-06-27T06:00:00.000Z","updated":"2020-07-25T09:19:03.467Z","comments":true,"path":"2020/ckdud69gn0015369k2sn7d7ii/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gn0015369k2sn7d7ii/","excerpt":"","text":"区别：静态库和动态库最本质的区别就是：该库是否被编译进目标（程序）内部。 静态（函数）库一般拓展名为（.a或者.lib),这类的函数库通常拓展名为libxxx.a或者xxx.lib。这类库在编译的时候会直接整合到目标程序中，所以利用静态函数库编译程的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。 动态函数库动态函数库的拓展名一般为 （.so或.dll)，这类函数库通常名为libxxx.so或xxx.dll。与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序中只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。 总结 从产品化的角度，发布的算法库和功能库尽量使用动态库，这样方便更新和升级，不必重新编译整个可执行文件，只需新版本动态库替换掉旧动态库即可。 从函数库集成的角度，若要将发布的所有子库（不止一个）集成成一个动态库向外提供接口，那么就需要将所有子库编译为静态库，这样所有子库就可以全部编译进目标动态库中，由最终的一个集成库向外提供功能。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"什么是死锁？在什么情况下产生？怎么解决？","slug":"deadlock","date":"2020-06-23T06:00:00.000Z","updated":"2020-07-25T09:20:12.901Z","comments":true,"path":"2020/ckdud69g10001369kgrgrdraj/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69g10001369kgrgrdraj/","excerpt":"","text":"在多道程序环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么等待进程有可能再也无法改变状态。这种情况称为死锁（deadlock）。 死锁的必要条件：如果在一个系统中以下四个条件同时成立，那么就能引起死锁： 互斥（ mutual exclusion）：至少一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。 占有并等待（ hold and wait ）：一个进程应占有至少一个资源，并等待另一个资源，该资源为其他进程所占有。 非抢占（ no preemption ）：资源不能被抢占，即资源只能被进程完成任务后自愿释放。 循环等待（ circular wait ）：有一组等待进程{P0,P1,···，Pn},P0等待的资源为P1占有，P1等待的资源为P2占有，·······，P（n-1）等待的资源为Pn占有，Pn等待的资源被P0占有。 四个条件必须同时成立才会出现死锁。循环等待条件意味着占有并等待条件，这样四个条件并不完全独立。 一般来说，处理死锁问题有三种方法： 通过协议来预防和避免死锁，确保系统不进入死锁状态。 可以允许系统进入死锁状态，然后检测它，并加以恢复。 可以忽视这个问题，认为死锁不可能在系统内发生。 第三种解决为大多数操作系统所采用，包括Linux和windows。因此应用程序开发人员需要自己编写程序，以便处理死锁。 死锁预防 死锁避免 死锁检测 死锁恢复。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"虚函数","slug":"virtual","date":"2020-06-20T10:22:26.698Z","updated":"2020-07-25T09:03:11.346Z","comments":true,"path":"2020/ckdud69hc002e369k3pvdc6cq/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69hc002e369k3pvdc6cq/","excerpt":"","text":"定义在c++中，基类必须指出派生类重定义哪些函数，定义为virtual的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。（c++ primer） 动态绑定在C++中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）即可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。 保留字virtual的目的是启用动态绑定。成员默认是非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型类型前面加上保留字virtual。除了构造函数外，任何非static成员函数都可以是虚函数。保留字virtual只能在类内部的成员函数声明中出现，不能在类定义体外部出现的函数定义上。 派生类与虚函数尽管不是必须这么做，派生类一般会重定义所继承的虚函数。如果派生类没有重定义某个虚函数，则使用基类中定义的版本。派生类必须对想要重定义的每个继承成员进行声明。派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 tips：一旦函数在基类中声明为虚函数，他就一直为虚函数，派生类无法改变该函数为虚函数这一事实。派生类重定义虚函数时，可以使用virtual保留字，但不是必须这么做。 覆盖虚函数机制在某些情况下，希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，这时可以用作用域操作符： 123Item_base *baseP &#x3D; &amp;derived;&#x2F;&#x2F; calls version from the base class regardless of the dynamic type of basePdouble d &#x3D; baseP -&gt; Item_base::net_prise(42); 这段代码强制将net_price调用确定为Item_base中定义的版本，该调用将在编译时确定。为什么会希望覆盖虚函数机制？最常见的理由是为了派生类虚函数调用基类中的版本。在这种情况下，基类版本可以完成继承层次中所有类型的公共任务，而每个派生类型只添加自己的特殊工作。 tips：派生类虚函数调用基类版本时，必须显式使用作用域操作符。如果派生类忽略这样做，则函数调用会在运行时确定并且将是一个自身调用，从而导致无穷递归。 虚函数与默认实参像其他任何函数一样，虚函数也可以有默认实参值，该值将在编译时确定。如果一个调用省略了具有默认值的实参，则所用的值由调用该函数类型定义，与对象的动态类型无关。通过基类的引用或指针调用虚函数时，默认实参为在基类虚函数声明中指定的值，如果通过派生类的指针或引用调用虚函数，则默认实参是在派生类版本中声明的值。 在同一虚函数的基类版本和派生类版本中使用不同的默认实参几乎一定会引起麻烦。如果通过基类的引用或指针调用虚函数，但实际执行的是派生类中定义的版本，这时就可能会出现问题。在这种情况下，为虚函数的基类版本定义的默认实参将传给派生类定义的版本，而派生类版本是用不同的默认实参定义的。 c++的多态性引用和指针的静态类型和动态类型可以不同，这是C++用以支持多态性的基石。 通过基类引用或指针调用基类中定义的函数时，我们并不知道执行函数的对象的确切类型，执行函数的对象可能是基类类型的，也可能是派生类型的。 如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定的或指针所指向的对象所属类型定义的版本。 虚析构函数自动调用基类部分的析构函数对基类的设计有重要影响。 删除指向动态分配对象的指针时，需要运行析构函数在释放对象的内存之前清理对象。处理继承层次中的对象时，指针的静态类型可能与删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。 如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际时派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数： 12345class Item_base &#123;public: &#x2F;&#x2F; no work,but virtual destructor needed &#x2F;&#x2F; if base pointer that points to a derived object is ever deleted virtual ~Item_base() &#123; &#125; 如果析构函数为虚函数，那么通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同： 1234Item_base *itemP &#x3D; new Item_base; &#x2F;&#x2F; same static and dymatic type delete item; &#x2F;&#x2F; ok:destructor for Item_base calleditemP &#x3D; new Bulk_item; &#x2F;&#x2F; ok:static and dynamic types differdelete itemP; &#x2F;&#x2F; ok:destructor for Bulk_item called 像其他虚函数一样，析构函数的性质都将继承。因此，如果层次中根类的析构函数也虚函数，则派生类析构函数也将是虚函数，无论派生类显式定义析构函数还是使用合成析构函数，派生类析构函数都是虚函数。 基类虚构函数式三法则的一个重要例外。三法则指出，如果类需要析构函数，则类几乎也确实需要其他复制控制成员，基类几乎总是需要析构函数，从而可以将析构函数设定为虚函数。如果基类为了将析构函数设为虚函数而具有空析构函数，那么，类具有析构函数并不表示需要赋值操作符或复制构造函数。 tips：即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。 构造函数和复制操作符不是虚函数在复制控制成员中， 只有析构函数应定义为虚函数，构造函数不能定义为虚函数。构造函数是对对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。 虽然可以在基类中将对象成员函数 operator=定义为虚函数，但这样做并不影响派生类中使用的复制操作符。每个类有自己的赋值操作符，派生类中的赋值操作符有一个与类本身类型相同的形参，该类型必须不同于继承层次中任何其他类的赋值操作符的形参类型。 将赋值操作符设为虚函数可能会令人混淆，因为虚函数必须在基类和派生类中具有相同的形参。基类赋值操作符有一个形参是自身类类型的引用，如果该操作符为虚函数，则每个类型都将得到一个虚函数成员，该成员定义了参数为一个基类对象的operator=。但是，对派生类而言，这个操作符与赋值操作符是不同的。 tips：将类的赋值操作符定义为虚函数很可能令人混淆，而且没什么用处。 构造函数和析构函数中的虚函数构造派生类对象时首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。 撤销派生类对象时，首先撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。 在这两种情况下，运行构造函数或析构函数的时候，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象作为基类类型对象对待。 构造或析构期间的对象类型对虚函数的绑定有影响。 tips：如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。 无论由构造函数（或析构函数）直接调用虚函数，或者从构造函数（或虚构函数）所调用的函数间接调用虚函数，都应用这种绑定。 要理解这种行为，考虑如果从基类构造函数（或析构函数）调用虚函数的派生类版本会怎样。虚函数的派生类版本很可能会访问派生类对象的成员，毕竟，如果派生类版本不需要使用派生类对象的成员，派生类多半能够使用基类中的定义。但是，对象的派生部分的成员不会在基类构造函数运行期间初始化，实际上，如果允许这样的访问，程序很可能会崩溃。","categories":[{"name":"c++","slug":"c","permalink":"https://shen-yu.gitee.io/categories/c/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"new与malloc的区别","slug":"new_and_malloc","date":"2020-06-18T16:15:16.710Z","updated":"2020-06-18T16:16:47.994Z","comments":true,"path":"2020/ckdud69gr001k369khcv09dku/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gr001k369khcv09dku/","excerpt":"","text":"1. molloc与free是C++/c语言的标准函数， new/delete是c++的运算符。2.他们都可以用于申请动态内存和释放内存。new/delete比molloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。既然new/delete的功能完全覆盖了malloc和free， 为什么c++中不把malloc/free淘汰出局呢？因为c++程序经常要调用c语言，而c语言只能用malloc/free管理动态内存。3. new返回指定类型的指针，并且可以自动计算出所需要的大小。malloc必须用户指定大小，并且默认返回类型为void*， 必须强制转换为实际类型的指针。","categories":[],"tags":[]},{"title":"进程和线程","slug":"process","date":"2020-06-17T06:00:00.000Z","updated":"2020-07-25T09:19:45.091Z","comments":true,"path":"2020/ckdud69gq001g369k1k590l4p/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gq001g369k1k590l4p/","excerpt":"","text":"什么是进程 进程是正在运行的一个应用程序，程序一旦运行就是进程。 进程是系统进行资源分配的最小单位，每个进程拥有独立的地址空间。 一个进程无法直接去访问另外一个进程的变量和数据结构，需要进行进程间通信，包括管程，消息队列。 线程是进程的一个实体，是资源调度的基本单位。 进程与线程的区别 同一进程的线程共享进程的地址空间，而进程之间则是独立的地址空间 同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃后，整个进程崩溃 进程切换，消耗资源大，线程切换时间少于进程 二者均可以并发执行","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"java的基本程序设计结构","slug":"javav1ch03","date":"2020-03-18T06:00:00.000Z","updated":"2020-07-25T09:18:33.115Z","comments":true,"path":"2020/ckdud69gk000x369kh8b29smv/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gk000x369kh8b29smv/","excerpt":"","text":"最简单的Java程序 java区分大小写 java应用程序的全部内容必须放置在类中 每个句子由分号结尾，回车不是句子的结尾 注释 单行注释// 多行注释/* */ 自动生成文档/** */ 基本数据类型整形 int 4字节 short 2字节 long 8字节 byte 1字节 浮点型 float 4字节 double 8字节 char类型 常用字符采用单字节编码，，而另一些字符而需要两个或者更多个字节。在Java中采用UTF-16所以占用2字节 boolean（布尔）类型 1位 只有0和1 1字节 1字节是计算机处理最小单位 4字节 java虚拟机规范里规定 变量 命名允许字符，数字和字母。字母包括’A’ ~ ‘Z’、 ‘a’ ~ ‘z’、’_’、’$’或者某种语言中表示字母的任何Unicode字符。数字包括’0’ ~ ‘9’和某种语言中表示数字的任何Unicode字符。 利用关键字final指示常量 声明一个变量后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化对变量 运算符 各运算符的优先级 各数据类型之间的强制类型转换 字符串 字符串的不可变属性 字符串类的一些常用接口 输入与输出 读取输入 格式化输出 文件的输入与输出 流程控制 if else while do while for break 提供了带标签选项 switch continue 提供了带标签选项 大数值 满足更高精度要求的计算 运算需要使用类内方法 数组 for each 数据变量是一种引用 多维数组 不规则数组 XMind: ZEN - Trial Version","categories":[{"name":"java","slug":"java","permalink":"https://shen-yu.gitee.io/categories/java/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"数据链路层","slug":"Data-Link-Layer","date":"2020-03-08T12:28:52.720Z","updated":"2020-07-25T08:55:18.010Z","comments":true,"path":"2020/ckdud69fx0000369khme1h06q/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69fx0000369khme1h06q/","excerpt":"","text":"使用点对点信道的数据链路层点对点信道的数据链路层在进行通信时的主要步骤如下 1.结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧 2.结点A把封装好的帧发生发生给结点B的数据链路层 3.若结点B的数据链路层收到的帧无差错，则从收到的帧中提取 出IP数据报交给上面的网络层；否则丢弃这个帧 三个基本问题 封装成帧 在一段数据的前后分布添加首部和尾部，这样就构成了一个帧 MTU(Maximum Transfer Unit)最大传送单元是指帧的数据部分长度上限,默认值1500字节 透明传输 “透明”表示某一个实际存在的事物看起来却好像不存在。这些数据就“看不见”数据链路层有什么防碍数据传输的东西。 为解决透明传输问题，发送端的数据链路层在出现控制字符“SOH”和“EOT”之前加入转义字符“ESC”，在接收端的数据链路层把数据运往网络层之前删除这些之前插入的转义字符。这种方法叫字节填充或字符填充。 差错检测 误码率 在一段时间内，传输错误的比特占所传输比特总数的比率 循环冗余检测CRC(Cyclic Redundancy Check) 在每组数据后面增加n位冗余码供差错检测 帧检验序列FCS(Frame Check Sequence) CRC是一种检错方法，而FSC是添加在数据后面的冗余码，在检错方法上可以选用CRC，但也可以不选用CRC 数据链路层若仅仅使用CRC差错检测技术，则只能做到对帧但无差错接收 传输差错 比特差错 比特在传输过程中可能会产生差错，1变0，0变1 没有比特差错 帧丢失 帧重复 帧失序 对于通信质量较差但无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务 点对点协议PPP(Point -to-Point Protocol)特点 应该满足的需求 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 组成 一个将IP数据报封装到串行链路的方法。PPP既支持异步链路（无奇偶检验的8比特数据），也支持面向比特的同步链路。IP数据报在PPP帧中就是信息部分。这个信息部分长度受最大传送单元MTU限制 一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)。通信双方可以协商一些选项。在RFC 1661中定义了11种类型的LCP分组 一套网络控制协议NCP(Network Control Protocol),其中的每个协议支持不同的网络层协议，如IP、OSI的网络层、DECnet、以及AppleTalk等。 帧格式 各字段意义 首部的第一个字段和尾部的第二个字段F(Flag),规定为0x7E 首部中的字段A规定为0xFF，控制字段C规定为0x03。最初考虑以后再对这两个字段的值进行定义，但自今也没有给出。 PPP首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示网络层的控制数据。 信息字段的长度是可变的，不超过1500字节 尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS 字节填充 当PPP使用异步传输时，他把转义符定义为0x7D，并使用字节填充 把信息字段中出现的每一个0x7E字节转变为2字节序列(0x7D,0x5E) 若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合），则把0x7D转变为2字节序列(0x7D,0x5D) 若信息字段中出现ASCII码的控制符（即树枝小于0x20的字符），则在字符前面加上一个0x7D字节，同时把该字符的编码加以改变。例如，出现0x03就把它转变为2字节序列(0x7D,0x23) 零比特填充 PPP协议用在SONET/SDH链路时，使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送） 在发送端，先扫描整个信息字段（通常用硬件实现，但也是可用软件实现，只是会慢些）。只要发现有5个连续1，则立即填入一个0.因此经过这个零比特填充后的数据，就可以保证在信息字段不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的0删除，以还原成原来的信息比特流 工作状态 当用户拨号接入ISP后，就建立一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组以及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一些临时的IP地址。这样，用户个人电脑就称为互联网上的一个有IP地址的主机了 使用广播信道的数据链路层局域网的数据链路层 局域网的优点 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源 便于系统的扩展和逐渐演变，各设备的位置可灵活调节和改变 提高了系统的可靠性、可用性和生存性 局域网按网络拓扑分类 星形网 环形网 总线网 共享信道技术上的两种方法 静态划分信道 频分复用、时分复用、波分复用和码分复用等，用户只要分配到了信道就不会和其他用户发送冲突。但这种方法代价较高，不适合局域网使用 动态媒体接入控制 随机接入 随机接入的特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多但用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发送了冲突），使得这些用户但发送都失败。因此，必须有解决碰撞的网络协议。 受控接入 受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling），或称为轮询。 IEEE802委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制（LLC）子层（与传输媒体无关）和媒体接入控制子层（MAC）子层（与传输媒体有关）。但现在LLC子层已成历史。MAC（Medium Access Control）LLC（Logical Link Control） 计算机与外界局域网的通信要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的ROM中 CSMA/CD协议 协议要点 多点接入 说明这是总线型网络，许多计算机以多点接入的方式连接在一个总线上 载波监听 载波监听就是检测信道。不管发送前，还是发送中，每个站都必须不停地检测信道 碰撞检测 就是“便发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据 总结 准备发送 适配器从网络层获得一个分组，加上以太网的首部和尾部，以组成以太网帧，放入适配器的缓存中。但是发送之前，必须先检测信道 检测信道 若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。 在发送过程中仍不停地检测信道，即网络适配器要边发送边监听 发送成功：争用期内一直为检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到准备发送的状态。 发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着执行指数退避算法，等待r倍512比特时间后，返回到检测信道。但若重传达16次仍不成功，则停止重传而向上报错 集线器 使用集线器物理上是星型网实际，在逻辑上仍然是一个总线网，各站使用的还是CSMA/CD协议 集线器有很多接口，很像一个多接口的转发器 集线器工作在物理层，工作只是简单地转发，不进行碰撞检测 集线器采用了专门的芯片，进行自适应串音回波抵消 以太网的MAC层（medium access control） MAC层的硬件地址 硬件地址又称为物理地址或MAC地址 MAC地址固化在适配器的ROM中 MAC帧的格式 第一个字段：6字节长的目的地址 第二个字段：6字节长的源地址 第三个字段：2字节长的类型字段 IP数据报：0x0800 Novell IPX：0x8137 第四个字段：长度在46到1500字节之间的数据字段 第五个字段：4字节的帧检验序列FCS（使用CRC检验） 扩展的以太网 使用集线器在物理层扩展以太网 交换式集线器常称为以太网交换机或第二层交换机（工作在数据链路层）。他就是一个多接口的网桥，而每个接口都直接与某台主机或另一个集线器相连，且工作在全双工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据 XMind: ZEN - Trial Version","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"我的博客诞生了","slug":"my-first-blog","date":"2020-03-05T06:00:00.000Z","updated":"2020-07-25T09:23:47.738Z","comments":true,"path":"2020/ckdud69gp001d369khtzqcm32/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69gp001d369khtzqcm32/","excerpt":"","text":"环境配置 macbook pro 2019 前期准备下载并安装 git node.js tips：如果下载速度过慢，可以找下国内镜像仓库npm的国内镜像https://npm.taobao.org/mirrors/上面这个网址里也有git的资源 安装hexo$ npm install -g hexo-cli github仓库建立仓库名必须满足：&lt;用户名&gt;.github.io github pages部署 安装hexo-deployer-gitnpm install hexo-deployer-git 修改配置文件_config.yml1234delpoy: type: git repo: https:github.com&#x2F;&lt;用户名&gt;&#x2F;&lt;用户名&gt;.github.io branch:gh-pages 运行hexo clean &amp;&amp; hexo deploy 查看你的github网站是否更改","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shen-yu.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"实践记录","slug":"实践记录","permalink":"https://shen-yu.gitee.io/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-03T06:00:00.000Z","updated":"2020-07-25T09:22:03.544Z","comments":true,"path":"2020/ckdud69ge000h369khsef703q/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckdud69ge000h369khsef703q/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shen-yu.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"实践记录","slug":"实践记录","permalink":"https://shen-yu.gitee.io/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]}]}