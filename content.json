{"meta":{"title":"猪猪侠","subtitle":"做一只想飞的猪","description":"一个猪窝","author":"Jiaxi Zhang","url":"https://shen-yu.gitee.io","root":"/"},"pages":[{"title":"tags","date":"2020-03-06T12:46:12.000Z","updated":"2020-03-06T12:59:06.971Z","comments":true,"path":"tags/index.html","permalink":"https://shen-yu.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-06T12:46:23.000Z","updated":"2020-03-06T12:46:23.862Z","comments":true,"path":"friends/index.html","permalink":"https://shen-yu.gitee.io/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-06T12:45:58.000Z","updated":"2020-07-25T09:01:07.234Z","comments":true,"path":"about/index.html","permalink":"https://shen-yu.gitee.io/about/index.html","excerpt":"","text":"A Coder, Live in Hangzhou, China 姓名：张嘉喜现居：杭州github：omgggboyQQ：171496079微信：m171496079————————————————————————————浙江大学软件工程硕士在读，硕士一年级。目前在浙江大学计算机辅助设计与图形学(cad&amp;cg)国家重点实验室主要研究数据可视化c++精通，qml精通，计算机图像学入门 目前主要进行电力展示沙盘项目的开发，该项目已经被部分省份使用，正在不断迭代更新。 博客拿来记录学习和分享生活，欢迎交流"},{"title":"categories","date":"2020-03-06T12:46:38.000Z","updated":"2020-03-06T12:58:13.714Z","comments":true,"path":"categories/index.html","permalink":"https://shen-yu.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"硬件加速的SIMD运算","slug":"SIMD","date":"2020-09-14T06:00:00.000Z","updated":"2020-09-22T12:54:56.434Z","comments":true,"path":"2020/ckfdz0o4v000kai9k44ng2gom/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4v000kai9k44ng2gom/","excerpt":"","text":"前言由于在查看ungine源码时查看到相关方面内容，回来复习一下游戏引擎架构的知识。 单指令多数据(single instruction multiple data, SIMD)是指，现代微处理器能用一个指令并行地对多个数据执行数学运算。例如，CPU可通过一个指令，把4对浮点数并行地相乘。SIMD广泛地应用在游戏引擎的数学库中，因为它能迅速地执行常见的矢量运算，如点积和矩阵乘法。 1994年，因特尔（Intel）首次把多媒体拓展（multimedia extension, MMX)指令集加进去奔腾CPU产品线中。把8个8位整数、4个16位整数或2个32位整数载入特设的64位MMX寄存器后，MMX指令集就能对那些寄存器进行SIMD运算。英特尔陆续加入多个版本的扩展指令集，称为单指令多数据流扩展(streaming SIMD extensions, SSE)，其中第一个SSE版本出现在奔腾Ⅲ处理器。SSE指令采用128位寄存器， 可存储整数或IEEE浮点数。 游戏引擎中最常用的SSE模式为32位浮点数包裹模式(packed 32-bit floating-point mode)。在此模式中，4个32位float值被打包进单个128位寄存器，单个指令可对4对浮点数进行并行运算，如加法或乘法。当要计算四元数矢量和$4 \\times 4$矩阵相乘时，This si just what the doctor ordered。 SSE寄存器在32位浮点包裹模式中，每个SSE寄存器含4个32位浮点数。为方便起见，我们将SSE寄存器中的4个浮点数称作$\\begin{bmatrix}x&amp;y&amp;z&amp;w\\end{bmatrix}$, 如同齐次坐标的矢量/矩阵运算时的表示方式。 为示范SSE寄存器如何运作，以下举一个SIMD指令的例子：1addps xmm0, xmm1addps指令把128位XMM0寄存器的4个浮点数分别与XMM1寄存器的4个浮点数相加，然后将4个运算结果写回XMM0。换一种方式表示： xmm0.x = xmm0.x + xmm0.xxmm0.y = xmm0.y + xmm0.yxmm0.z = xmm0.z + xmm0.zxmm0.w = xmm0.w + xmm0.w存储于SSE寄存器的4个浮点数，可以分别抽出存进内存，或从内存载入，但是这类操作速度相对较慢。在x87FPU(floating-point unit)寄存器和SSE寄存器之间传送数据很糟糕，因为CPU必须等待x87单元或SSE单元完成所有正在进行的工作。这样会令CPU的整个指令执行流水线停顿(stall)，导致大量CPU周期被浪费。简而言之，应把普通浮点数运算和SIMD运算的混合代码视作瘟疫尽量避免。 为了把内存、x87FPU寄存器和SSE寄存器之间的数据传输量降至最低，多数SIMD运算库都会尽量把数据保存在SSE寄存器中，而且越久越好。这意味着，标量值也保留在SSE寄存器里，而不把它传送在float变量。例如，两个矢量点积的结果是一个标量，但若把该标量留在SSE寄存器中，就可供稍后的矢量运算，而不会带来额外传输成本。可把单个浮点值复制至SSE寄存器的4个“位置”以表示标量。因此如要将一个标量s存储至SSE寄存器，就会设x=y=z=w=s。 __m128数据类型用C/C++中，使用这些神奇的SSE128位值颇为容易。微软Visual Studio编译器提供了内建的__m128数据类型。此数据类型可以来声明全局变量、自动变量，甚至是类或结构里的成员变量。在大多数情况下，此数据类型的变量会存储于内存中，但在计算时，__m128的值会直接在CPU的SSE寄存器中运用。事实上，以__m128声明的自动变量或函数参数，编译器通常会把它们直接置于SSE寄存器中，而非置于内存中的程序堆栈。 另一方面：gcc的vector类型GNUC/C++ 编译器gcc(如用于编译PS3上的代码)提供了一系列128位矢量类型、类似于Visual Studio的__m128。这些类型的声明如同一般C/C++类型，仅需在类型前加上关键字vector。例如，可用vector flaot 去声明一个包含4个float的SIMD变量。gcc也提供在源文件里编写SIMD字面量的方法。例如，你可以这样初始化一个vector float：1vector float v &#x3D; (vector float)(-1.0f, 2.0f, 0.5f, 1.0f); 对应的Visual Studio代码要复杂一些：12&#x2F;&#x2F; 使用编译器的内部函数（intrinsic）载入“字面量”值__m128 v &#x3D; _mm_set_ps(-1.0f, 2.0f, 0.5f, 1.0f); __m128变量的对齐当将一个__m128变量存储在内存中，程序员有责任确保变量是16字节对齐的。这意味着，当把__m128变量的地址以十六进制表示时，其最低有效半字节必须总是0x0。编译器会自动为类和结构加入填充（padding），因此，整个类和结构是16字节对齐的，置于其中的所有__m128成员变量也会正确地对齐。若声明含一个或多个__m128的自动全局类/结构，则编译器会自动把对象对齐。然而，当编译器要动态地分配数据结构（即用malloc（）或new（）分配数据）时，程序员就必须负责对齐，编译器帮不上忙。 用SSE内部函数编码SSE运算可用原始的汇编语言实现，也可使用C/C++ 中的内联汇编（inline assembly）实现。然而，这样做不但缺乏可移植性，而且编程也令人头疼。为了更加简便，如见的编译器都提供内部函数(intrinsic)。内部函数是一些特殊指令，其形式和作用都很像普通的C函数，但编译器会把他们转化为内部汇编代码。多数内部函数会被翻译成单个汇编语言指令，但有些内部函数是宏，这些宏会被翻译为一串指令。 .cpp文件需#include 才能使用__m128数据类型和SSE内部函数。 我们在从另一个角度看一下addps汇编语言指令。在C/C++中可用_mm_add_ps()内部函数执行这条指令。以下并列比较使用内联汇编和内部函数的代码。12345678910111213__m128 addWithAssembly(const __m128 a, const __m128 b)&#123; &#x2F;&#x2F; 注意：有赖于调用约定，a和b已分别存储在xmm0和xmm1 __asm addps xmm0, xmm1 &#x2F;&#x2F; 注意：根据调用约定，xmm0 负责存储一个 __m128 返回值， &#x2F;&#x2F; 所以我们不需任何事情去返回结果——甚至不需要return语句！&#125;__m128 addWithIntrinsics(const __m128 a, const __m128 b)&#123; return _mm_add_ps(a,b);&#125; 这两个实现乍看起来大概是等价的。然而，注意在汇编语言版本中，我们必须用__asm关键字去使用内联汇编，也必须依靠一些专门的编译器调用约定知识，才能访问函数的参数和返回值。这样令编写函数更困难一些，最后的代码也完全缺乏可移植性。 另一方面，使用内部函数的版本不涉及内联汇编，该SSE汇编指令如同正常的函数一般。此版本更直观，更清晰，源代码的可移植性也更好。而且，使用内部函数为编译器提供了额外的“元信息”去优化代码。当你使用__asm关键字时，编译器不能做出任何假设，因而限制了其优化能力。 读者可对这些例子里的函数做实验，下面的main()函数作为测试平台。注意其中使用了两个新的内存函数：_mm_set_ps()把4个浮点值初始化为一个__m128变量，_mm_load_ps()把内存中的float数组载入__m128变量（即SSE寄存器）。还要注意这4个全局float数组都使用__declspec(align(16))强制声明了16字节对齐。若略去这个指令(directive),根据所用的目标硬件，程序运行时可能会崩溃，或是性能会明显降低。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;xmmintrin.h&gt;&#x2F;&#x2F; ······定义之前那两个函数······void testSSE()&#123; __declspec(align(16)) float A[4]; __declspec(align(16)) float B[4] &#x3D; &#123; 8.0f, 6.0f, 4.0f, 2.0f &#125;; __declspec(align(16)) float C[4]; __declspec(align(16)) float D[4]; &#x2F;&#x2F; 使用字面量设置 a &#x3D; (1,2,3,4), 并且 &#x2F;&#x2F; 从浮点数组载入 b &#x3D; (2, 4, 6, 8) &#x2F;&#x2F; (只是用于演示两种方法) &#x2F;&#x2F; 注意， B[] 是从后至前写入的， 因为Intel是小端机器 __m128 a &#x3D; _mm_set_ps(1.0f, 2.0f, 3.0f, 4.0f); __m128 b &#x3D; _mm_load_ps(&amp;B[0]); &#x2F;&#x2F; 测试那两个函数 __m128 c &#x3D; addWithAssembly(a, b); __m128 d &#x3D; addWithIntrinsics(a, b); &#x2F;&#x2F; 把a和b的值存储回原来的数组，才能打印 _mm_store_ps(&amp;A[0], a); _mm_store_ps(&amp;B[0], b); &#x2F;&#x2F; 把两个结果存储至数组，方便打印 _mm_store_ps(&amp;C[0], c); _mm_store_ps(&amp;D[0], d); &#x2F;&#x2F; 检查结果（注意结果是从后往前的，因为Intel是小端机器） printf(&quot;a &#x3D; %g %g %g %g\\n&quot;, A[0], A[1], A[2], A[3]); printf(&quot;b &#x3D; %g %g %g %g\\n&quot;, B[0], B[1], B[2], B[3]); printf(&quot;c &#x3D; %g %g %g %g\\n&quot;, C[0], C[1], C[2], C[3]); printf(&quot;d &#x3D; %g %g %g %g\\n&quot;, D[0], D[1], D[2], D[3]); return 0;&#125; SSE文档中的约定至此我们应该稍停一会儿去看看相关的约定。在微软的文档中，当提到SSE寄存器中的个别32位浮点数的名字时，便会采用$\\begin{bmatrix} x&amp;y&amp;z&amp;w \\end{bmatrix}$的约定。在本书中，我们使用$\\begin{bmatrix} x&amp;y&amp;z&amp;w \\end{bmatrix}$的约定。这仅仅是一个命名问题，怎么称呼SSE寄存器中的元素是无所谓的，只要能前后一致地诠释每个元素即可。或许最简单的方法是把SSE寄存器r想象成包含元素$\\begin{bmatrix} r{0}&amp;r{1}&amp;r{2}&amp;r{3} \\end{bmatrix}$。 用SSE实现矢量和矩阵的相乘让我们来看看如何用SSE实现矢量和矩阵的相乘。目的是把$1 \\times 4$的矢量$v$和$4 \\times 4$的矩阵$M$相乘，得出成绩矢量$r$。 r = vM\\begin{bmatrix} r_{x}&r_{y}&r_{z}&r_{w}\\end{bmatrix} = \\begin{bmatrix} v_{x}&v_{y}&v_{z}&v_{w}\\end{bmatrix}\\begin{bmatrix} M_{11}&M_{12}&M_{13}&M_{14}\\\\ M_{21}&M_{22}&M_{23}&M_{24}\\\\M_{31}&M_{32}&M_{33}&M_{34}\\\\M_{41}&M_{42}&M_{43}&M_{44}\\end{bmatrix} = \\begin{bmatrix} v_{x}M_{11}+v_{y}M_{21}+v_{z}M_{31}+v_{w}M_{41}\\\\ v_{x}M_{12}+v_{y}M_{22}+v_{z}M_{32}+v_{w}M_{42}\\\\v_{x}M_{13}+v_{y}M_{23}+v_{z}M_{33}+v_{w}M_{43}\\\\v_{x}M_{14}+v_{y}M_{24}+v_{z}M_{34}+v_{w}M_{44}\\end{bmatrix}^{T}此乘法涉及计算行矢量$v$和列矢量$M$矩阵的点积。若要使用SSE指令来计算，可先把$v$存储在SSE寄存器（__m128)，再把$M$矩阵的每个列矢量存储至SSE寄存器。那么就可用mulps指令并行计算所有的$v{k}M{ij}$:12345678910111213__m128 mulVectorMatrixAttemp1( const __m128&amp; v, const __m128&amp; Mcol1, const __m128&amp; Mcol2, const __m128&amp; Mcol3, const __m128&amp; Mcol4)&#123; const __m128 vMcol1 &#x3D; _mm_mil_ps(v, Mcol1); const __m128 vMcol2 &#x3D; _mm_mil_ps(v, Mcol2); const __m128 vMcol3 &#x3D; _mm_mil_ps(v, Mcol3); const __m128 vMcol4 &#x3D; _mm_mil_ps(v, Mcol4); &#x2F;&#x2F; ······然后呢？&#125;以上代码能求出以下这些中间结果: vMcol1 = \\begin{bmatrix}v_{x}M_{11}&v_{y}M_{21}&v_{z}M_{31}&v_{w}M_{41}\\end{bmatrix}vMcol2 = \\begin{bmatrix}v_{x}M_{12}&v_{y}M_{22}&v_{z}M_{32}&v_{w}M_{42}\\end{bmatrix}vMcol3 = \\begin{bmatrix}v_{x}M_{13}&v_{y}M_{23}&v_{z}M_{33}&v_{w}M_{43}\\end{bmatrix}vMcol4 = \\begin{bmatrix}v_{x}M_{14}&v_{y}M_{24}&v_{z}M_{34}&v_{w}M_{44}\\end{bmatrix}但问题如果是这么解决的话，就需要在寄存器内做加法，才能计算所需结果。例如，$r{x} = v{x}M{11} + v{y}M{21} + v{z}M{31} + v{w}M_{41}$,这就需要把vMcol1的4个分量相加。在SSE中，把寄存器内的分量相加是低效的（几乎所有SIMD架构都是这样的，包括PS3的Altivec）。再者，相加后的结果将分散在4个SSE寄存器中，那么还需要把它们结合到单个矢量r中。好在还有更好的做法。 这里的“技巧”是，使用M的行矢量相乘，而不是用列矢量。这样，就可以并行地进行加法，最终结果也会置于带入输出矢量r的单个SSE寄存器中。然而，在本技巧中不能直接用矢量v乘以M的行，而是需要用$vx$乘以第1行，$v_y$乘以第2行，$v_z$乘以第3行，$v_w$乘以第4行。要这么做，就需要把v里的单个分量如$v{x}$，复制（replicate）到其余的分量里去，生成一个$\\begin{bmatrix}v{x}&amp;v{x}&amp;v{x}&amp;v{x} \\end{bmatrix}$矢量。之后就可以用已复制x、y、z或w分量至整个寄存器即可：123456#define SHUFFLE_PARAM(x, y, z, w) ((x) | ((y) &lt;&lt; 2) | ((z) &lt;&lt; 4) | ((w) &lt;&lt; 6)#define _mm_replicate_x_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(0, 0, 0, 0))#define _mm_replicate_y_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(1, 1, 1, 1))#define _mm_replicate_z_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(2, 2, 2, 2))#define _mm_replicate_w_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(3, 3, 3, 3))给定这些方便的宏，就可以编写矢量矩阵乘法函数，如下所示：123456789101112131415161718__m128 mulVectorMatrixAttempt2(const __m128&amp; v,const __m128&amp; Mcol1,const __m128&amp; Mcol2,const __m128&amp; Mcol3,const __m128&amp; Mcol4)&#123; const __m128 xxxx &#x3D; _mm_replicate_x_ps(v); const __m128 yyyy &#x3D; _mm_replicate_y_ps(v); const __m128 zzzz &#x3D; _mm_replicate_z_ps(v); const __m128 wwww &#x3D; _mm_replicate_w_ps(v); cosnt __m128 xMrow1 &#x3D; _mm_mul_ps(xxxx, Mrow1); cosnt __m128 xMrow2 &#x3D; _mm_mul_ps(yyyy, Mrow2); cosnt __m128 xMrow3 &#x3D; _mm_mul_ps(zzzz, Mrow3); cosnt __m128 xMrow4 &#x3D; _mm_mul_ps(wwww, Mrow4); __m128 result &#x3D; _mm_add_ps(xMrow1, yMrow2); result &#x3D; _mm_add_ps(result, yMrow3); result &#x3D; _mm_add_ps(result, yMrow4); return result;&#125; 这段代码产生以下的中间矢量： xMrow1 = \\begin{bmatrix}v_{x}M_{11}&v_{x}M_{12}&v_{x}M_{13}&v_{x}M_{14}\\end{bmatrix}yMrow2 = \\begin{bmatrix}v_{y}M_{21}&v_{y}M_{22}&v_{y}M_{23}&v_{y}M_{24}\\end{bmatrix}zMrow3 = \\begin{bmatrix}v_{z}M_{31}&v_{z}M_{32}&v_{z}M_{33}&v_{z}M_{23}\\end{bmatrix}wMrow4 = \\begin{bmatrix}v_{w}M_{41}&v_{w}M_{42}&v_{w}M_{43}&v_{w}M_{44}\\end{bmatrix}把这4个中间矢量相加，就能求得结果r： r = \\begin{bmatrix} v_{x}M_{11}+v_{y}M_{21}+v_{z}M_{31}+v_{w}M_{41}\\\\ v_{x}M_{12}+v_{y}M_{22}+v_{z}M_{32}+v_{w}M_{42}\\\\v_{x}M_{13}+v_{y}M_{23}+v_{z}M_{33}+v_{w}M_{43}\\\\v_{x}M_{14}+v_{y}M_{24}+v_{z}M_{34}+v_{w}M_{44}\\end{bmatrix}^{T}对某些CPU来说，以上代码还可以进一步优化，方法是使用相对简单的乘并加（multiply-and-add)指令，通常表示为madd。此指令把前两个参数相乘，再把结果和第3个参数相加。可惜SSE并不支持madd指令，但我们可以用宏代替它，效果也不错：1234567891011121314#define _mm_madd_ps（a,b,c) _mm_add_ps(_mm_mul_ps((a), (b), (c))__m128 mulVectorMatrixFinal(const __m128 v, const __m128 Mrow4)&#123; __128 result; result &#x3D; _mm_mul_ps (_mm_replicate_x_ps(v), Mrow0); result &#x3D; _mm_replicate_y_ps(v), Mrow1, result); result &#x3D; _mm_replicate_y_ps(v), Mrow2, result); result &#x3D; _mm_replicate_y_ps(v), Mrow3, result); return result;&#125; 当然$4 \\times 4$矩阵对$4 \\times 4$的乘法也可以用类似的办法实现。当要计算$P=AB$时，我们要把A的每行当作矢量，并如mulVectorMatrixFinal()那样乘以B的每列，最后把点积的结果相加得到P中每行的结果。对于微软Visual Studio编译器提供的所有SSE内部函数，可参阅MSDN。","categories":[{"name":"游戏引擎架构","slug":"游戏引擎架构","permalink":"https://shen-yu.gitee.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"矩阵运算","slug":"矩阵运算","permalink":"https://shen-yu.gitee.io/tags/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"}]},{"title":"用户数据报协议UDP","slug":"UDP","date":"2020-09-11T06:00:00.000Z","updated":"2020-09-21T14:50:04.947Z","comments":true,"path":"2020/ckfdz0o4n0009ai9k395x5t0k/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4n0009ai9k395x5t0k/","excerpt":"","text":"概述用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。UDP的主要特点是： UDP是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。 UDP是尽最大努力交付，即不保证可靠交付，因此主机不需要维护复杂的连接状态表（这里面有许多参数）。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP过长的报文，UDP就照样发送，即一次发送一个报文。如下图所示。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交付给IP层后，IP层在传送时可能要进行分片，这降低IP效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。 UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送效率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且运行在网络发送拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好合适这种要求。 UDP支持一对一、一对多、多对一和多对多的交互通信。 UDP的首部开销小，只有8字节，比TCP的20个字节的首部要短。 UDP的首部格式用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下： 源端口： 源端口号。在需要对方回信时选用。不需要时可用全0. 目的端口： 目的端口号。这在终点交付报文时必须使用。 长度： UDP用户数据报的长度，其最小值是8（仅有首部）。 检验和： 检测UDP用户数据报在传输中是否有错。有错就丢弃。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"UDP","slug":"UDP","permalink":"https://shen-yu.gitee.io/tags/UDP/"}]},{"title":"客户机/服务器通信","slug":"csconection","date":"2020-09-08T06:00:00.000Z","updated":"2020-09-21T12:54:35.135Z","comments":true,"path":"2020/ckfdz0o4t000fai9kh5v367uk/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4t000fai9kh5v367uk/","excerpt":"","text":"在进程间通信已经列举了如何通过共享内存和消息传递进行通信。这些技术也可以用于客户机/服务器系统的通信。这里主要讨论客户机/服务器通信的三种其他策略：套接字、远程程序调用（RPC）和管道。 1.套接字套接字为通信的断点。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。每个套接字由一个IP地址和一个端口号组成。通常，套接字采用客户机-服务器架构。服务器通过监听指定端口，来等待客户机请求。服务器在收到请求后，接收来自客户套接字的连接，从而完成连接。 server.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib,&quot;ws2_32.lib&quot;) int main(int argc, char* argv[]) &#123; //初始化WSA WORD sockVersion = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData)!=0) &#123; return 0; &#125; //创建套接字 SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(slisten == INVALID_SOCKET) &#123; printf(&quot;socket error !&quot;); return 0; &#125; //绑定IP和端口 sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(slisten, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf(&quot;bind error !&quot;); &#125; //开始监听 if(listen(slisten, 5) == SOCKET_ERROR) &#123; printf(&quot;listen error !&quot;); return 0; &#125; //循环接收数据 SOCKET sClient; sockaddr_in remoteAddr; int nAddrlen = sizeof(remoteAddr); char revData[255]; while (true) &#123; printf(&quot;等待连接...\\n&quot;); sClient = accept(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen); if(sClient == INVALID_SOCKET) &#123; printf(&quot;accept error !&quot;); continue; &#125; printf(&quot;接受到一个连接：%s \\r\\n&quot;, inet_ntoa(remoteAddr.sin_addr)); //接收数据 int ret = recv(sClient, revData, 255, 0); if(ret &gt; 0) &#123; revData[ret] = 0x00; printf(revData); &#125; //发送数据 const char * sendData = &quot;你好，TCP客户端！\\n&quot;; send(sClient, sendData, strlen(sendData), 0); closesocket(sClient); &#125; closesocket(slisten); WSACleanup(); return 0; &#125; client.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;WINSOCK2.H&gt;#include&lt;STDIO.H&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#pragma comment(lib, &quot;ws2_32.lib&quot;) int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA data; if(WSAStartup(sockVersion, &amp;data)!=0) &#123; return 0; &#125; while(true)&#123; SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(sclient == INVALID_SOCKET) &#123; printf(&quot;invalid socket!&quot;); return 0; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); if(connect(sclient, (sockaddr *)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; //连接失败 printf(&quot;connect error !&quot;); closesocket(sclient); return 0; &#125; string data; cin&gt;&gt;data; const char * sendData; sendData = data.c_str(); //string转const char* //char * sendData = &quot;你好，TCP服务端，我是客户端\\n&quot;; send(sclient, sendData, strlen(sendData), 0); //send()用来将数据由指定的socket传给对方主机 //int send(int s, const void * msg, int len, unsigned int flags) //s为已建立好连接的socket，msg指向数据内容，len则为数据长度，参数flags一般设0 //成功则返回实际传送出去的字符数，失败返回-1，错误原因存于error char recData[255]; int ret = recv(sclient, recData, 255, 0); if(ret&gt;0)&#123; recData[ret] = 0x00; printf(recData); &#125; closesocket(sclient); &#125; WSACleanup(); return 0; &#125; 使用套接字的通信，虽然常用和高效，但是属于分布式进程之间的一种低级形式的通信。一个原因是，套接字只允许在通信进程之间交换无结构的字节流。客户机或服务器程序需要加上数据结构。下面种通信方法更加高效：远程程序调用（RPC）和管道。 2. 远程程序调用与IPC的消息不一样，RPC通信交换的消息具有明确结构，因此不再仅仅是数据包。消息传到RPC服务，RPC服务监听远程系统的端口号；消息包含用于指定：执行函数的一个标志符以及传递给函数的一些参数。然后，函数按要求来执行，而所有结果会通过另一消息，传递回到请求者。 端口只是一个数字，用于消息分组头部。 3. 管道管道允许两个进程进行通信。管道是早起UNIX系统最早使用的一种IPC机制。管道为进程之间的相互通信提供了一种较为简单的方法，尽管也有一定的局限性。在实现管道时，应该考虑一下四个问题： 管道允许单向通信还是双向通信？ 如果允许双向通信，他是半双工还是全双工？ 通信进程之间是否应该有一定的关系？ 管道通信能否通过网络，还是只能在同一台机器上进行？ 3.1普通管道普通管道允许两个进程按标准的生产者-消费者方式进行通信：生产者向管道的一端（写入端）写，消费者从管道的另一端（读出端）读。因此，普通管道是单向的，只允许单向通行。如果需要双向通信，那么就采用两个管道，而每个管道向不同方向发送数据。 UNIX的普通管道123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define BUFFER_SIZE 25#define READ_END 0#define WRITE_END 1int main(void)&#123;char write_msg[BUFFER_SIZE] = &quot;Greetings&quot;;char read_msg[BUFFER_SIZE&#125;;int fd[2];pid_t pid;/* create the pipe */if (pipe(fd == -1) &#123; fprintf(stderr, &quot;Pipe failed&quot;); return 1;&#125;/* fork a child process */pid = fork();if (pid &lt; 0) &#123; /* error occurred */ fprintf(stderr, &quot;Fork Failed&quot;); return 1;&#125;if (pid &gt; 0) &#123; /* parent process */ /* close the unused end of the pipe */ close(fd[READ_END]); /* write to the pipe */ write(fd[WRITE_END], write_msg, strlen(write_msg) + 1); /* close the read end of the pipe */ close(fd[WRITE_END]);&#125;else &#123; /* */","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程通信","slug":"进程通信","permalink":"https://shen-yu.gitee.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"}]},{"title":"unigine cantainers","slug":"containers_unigine","date":"2020-09-05T06:00:00.000Z","updated":"2020-09-14T09:17:37.260Z","comments":true,"path":"2020/ckfdz0o4p000aai9kb0bl5nh9/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4p000aai9kb0bl5nh9/","excerpt":"","text":"前言containers用于组织和分组单个wieights。 公共参数除了常规参数外，还有一组特定于容器的参数，任何容器都可以具有： space 整体间距（像素）。 space_x 水平间距（像素）。 space_y 垂直间距（像素）。 vbox 参数： parameters: 容器是否有背景。 默认值为0（布尔值）。12345&lt;vbox name=&quot;Test::vbox&quot; export=&quot;0&quot; space=&quot;8&quot;&gt; &lt;label&gt;&lt;text&gt;Label 0&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label 1&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label 2&lt;/text&gt;&lt;/label&gt;&lt;/vbox&gt; hbox 参数： parameters: 容器是否有背景。 默认值为0（布尔值）。12345&lt;vbox name=&quot;Test::hbox&quot; export=&quot;0&quot; space=&quot;8&quot;&gt; &lt;label&gt;&lt;text&gt;Label 0&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label 1&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label 2&lt;/text&gt;&lt;/label&gt;&lt;/hbox&gt; vpaned该小部件应恰好包含两个孩子。 参数: value 范围内的值[-32767; 32767]。 -32767表示在调整大小时，上层子级将保持固定。 32767表示在调整大小时，较低的子级将保持固定。 0表示两个子元素的大小均相等。 其他值指定比例，在比例中调整子项的大小。 默认值为0。 1234&lt;vpaned name=&quot;Test::vpaned&quot; align=&quot;expand&quot; value=&quot;-32767&quot;&gt; &lt;hbox&gt;…&lt;/hbox&gt; &lt;hbox&gt;…&lt;/hbox&gt;&lt;/vpaned&gt; hpaned该小部件应恰好包含两个孩子。 参数: value 范围内的值[-32767; 32767]。 -32767表示在调整大小时，上层子级将保持固定。 32767表示在调整大小时，较低的子级将保持固定。 0表示两个子元素的大小均相等。 其他值指定比例，在比例中调整子项的大小。 默认值为0。 1234&lt;hpaned name=&quot;Test::hpaned&quot; align=&quot;expand&quot; value=&quot;-32767&quot;&gt; &lt;vbox&gt;…&lt;/vbox&gt; &lt;vbox&gt;…&lt;/vbox&gt;&lt;/hpaned&gt; gridbox 参数： background 容器是否有背景。 默认值为1（布尔值）。 columns 列数（整数）。 123456&lt;gridbox name=&quot;Test::gridbox&quot; export=&quot;0&quot; columns=&quot;2&quot; space=&quot;8&quot;&gt; &lt;label&gt;&lt;text&gt;Label0&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label1&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label2&lt;/text&gt;&lt;/label&gt; &lt;label&gt;&lt;text&gt;Label3&lt;/text&gt;&lt;/label&gt;&lt;/gridbox&gt; groupbox 参数： background 容器是否有背景。 默认值为1（布尔值）。 特定孩子： text 可操作的标题文字 1234&lt;groupbox name=&quot;Test::groupbox&quot; export=&quot;0&quot; space=&quot;8&quot; align=&quot;center&quot;&gt; &lt;text&gt;Group&lt;/text&gt; &lt;label&gt;&lt;text&gt;Label0&lt;/text&gt;&lt;/label&gt;&lt;/groupbox&gt; tabbox 特定的孩子： tab 一个标签。支持多个标签。 每个选项卡还可以有一个特殊的子代： text 标签标题 123456789101112131415&lt;tabbox name=&quot;Test::tabbox&quot; export=&quot;1&quot; space=&quot;20&quot; align=&quot;expand&quot;&gt; &lt;tab&gt; &lt;text&gt;Tab 0&lt;/text&gt; &lt;label&gt;&lt;text&gt;TabBox content&lt;/text&gt;&lt;/label&gt; &lt;/tab&gt; &lt;tab&gt; &lt;text&gt;Tab 1&lt;/text&gt; &lt;/tab&gt; &lt;tab&gt; &lt;text&gt;Tab 2&lt;/text&gt; &lt;/tab&gt; &lt;tab&gt; &lt;text&gt;Tab 3&lt;/text&gt; &lt;/tab&gt;&lt;/tabbox&gt; scrollbox 参数： width 容器宽度（以像素为单位）。 height 容器高度（以像素为单位）。 henabled 是否启用水平滚动（布尔）。 venabled 是否启用垂直滚动（布尔）。 123&lt;scrollbox name=&quot;Test::scrollbox&quot; export=&quot;0&quot; space=&quot;8&quot; align=&quot;center&quot; width=&quot;100&quot; height=&quot;100&quot; hscroll=&quot;1&quot;&gt; &lt;label&gt;&lt;text&gt;LabelLabelLabelLabelLabelLabelLabelLabelLabel&lt;/text&gt;&lt;/label&gt;&lt;/scrollbox&gt; window参数： moveable 窗口是否可移动。 默认值为1（布尔值）。 sizeable 窗口是否可调整大小。 默认值为0（布尔值）。 titleable 窗口是否可以有标题。 默认值为0（布尔值）。 blendable 窗口不聚焦时是否变灰。 默认值为0（布尔值）。 floatable 窗口最小化是否具有动画效果。 默认值为0（布尔值）。 snap_distance 将小部件捕捉到应用程序窗口边界的最大距离。 默认值为0（像素）。 width 窗口宽度（以像素为单位）。 height 窗口高度（以像素为单位）。 特定的孩子: text 窗口标题。align 可以接受的参数center，left,right。 123&lt;window name=&quot;Test::window&quot; export=&quot;1&quot; snap_distance=&quot;16&quot; width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;text align=&quot;right&quot;&gt;Window title&lt;/text&gt;&lt;/window&gt; dialog参数： moveable 窗口是否可移动。 默认值为1（布尔值）。 sizeable 窗口是否可调整大小。 默认值为0（布尔值）。 titleable 窗口是否可以有标题。 默认值为0（布尔值）。 blendable 窗口不聚焦时是否变灰。 默认值为0（布尔值）。 floatable 窗口最小化是否具有动画效果。 默认值为0（布尔值）。 snap_distance 将小部件捕捉到应用程序窗口边界的最大距离。 默认值为0（像素）。 width 提示框宽度（以像素为单位）。 height 提示框高度（以像素为单位）。 特定的孩子: text 提示框标题。align 可以接受的参数center，left,right。 123&lt;dialog width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;text align=&quot;right&quot;&gt;Dialog title&lt;/text&gt;&lt;/dialog&gt; 参考以上内容均翻译自unigine官方文档。如有错误欢迎批评指正。","categories":[{"name":"unigine引擎","slug":"unigine引擎","permalink":"https://shen-yu.gitee.io/categories/unigine%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"containers","slug":"containers","permalink":"https://shen-yu.gitee.io/tags/containers/"}]},{"title":"unigine UI","slug":"uifiles_unigine","date":"2020-09-02T06:00:00.000Z","updated":"2020-09-14T09:17:35.797Z","comments":true,"path":"2020/ckfdz0o5o002iai9ka9jxcr73/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5o002iai9ka9jxcr73/","excerpt":"","text":"前言Unigine中的所有GUI元素都是通过XML格式的UI文件即时生成的。 这些文件描述了Unigine提供的容器和小部件。 它们中的每一个都由UI文件中的XML标记描述。 UI文件语法作为正确的XML文件，UI文件必须以标准声明开头。 第二个元素必需是根标签ui。 该根元素可以包含零个或多个指定该接口的其他元素（标签）。123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ui version=&quot;1.0&quot;&gt;&lt;/ui&gt;如果UI文件在语法上不正确，Unigine的控制台和主日志文件中会报错。 1所有UI文件被视为UTF-8编码即使您在声明中指定了另一种编码。并非所有可用的GUI元素都可以使用XML定义。 其中一些（例如操纵器和专用对话框）仅通过脚本设置。 参数几乎所有的UI文件标记都具有参数，并且最好了解以下一般规则： 作为参数值提供的所有尺寸均以像素为单位。 文件名是相对于根数据目录的。 颜色采用Web格式，即#RRGGBB或#RRGGBBAA格式。 RR，GG，BB和AA分别对应于十六进制颜色分量值-红色，绿色，蓝色和alpha； 值范围从00到FF。 布尔值可以以不同的形式设置。 对于FALSE，请使用：0，false，no。 对于TRUE，使用：1，true，yes。 这是带有参数的示例元素：1&lt;sprite align=&quot;overlap,top,right&quot; pos_x=&quot;10&quot; pos_y=&quot;-42&quot; texture=&quot;data/core/gui/unigine.png&quot;/&gt; 注释您可以使用标准的XML注释语法。 在处理UI文件期间，将跳过注释块。 注释示例：1&lt;!-- This section will be omitted--&gt; 共有参数所有GUI元素（容器和窗口小部件）都可以具有以下参数。 name小部件的唯一名称。 如果将export标志设置为yes，则在脚本中将使用该名称来引用小部件。 该名称可以包含名称空间规范和/或数组索引。1234&lt;!-- The following widget will be accessible via scripts as foo::bar --&gt;&lt;button name=&quot;foo::bar&quot; export=&quot;yes&quot;/&gt;&lt;!-- This widget will be accessible via scripts as fooArray[2] --&gt;&lt;button name=&quot;fooArray[2]&quot; export=&quot;yes&quot;/&gt; next小部件的名称，如果用户按下TAB键，它将在接下来获得焦点。 如果省略此参数，则紧随当前参数的窗口小部件将获得焦点。1234&lt;!-- Custom focus order: button_0 → button_2 → button_1 --&gt;&lt;button name=&quot;button_0&quot; next=&quot;button_2&quot;/&gt;&lt;button name=&quot;button_1&quot; next=&quot;button_0&quot;/&gt;&lt;button name=&quot;button_2&quot; next=&quot;button_1&quot;/&gt; align窗口小部件的一组对齐标志。 标志以逗号分隔。 可用的标志是： center left right top bottom expend 在可用空间中对齐文本。 overlop 将小部件放在父容器的内容上。 background 将小部件放置在同一容器中其他小部件的下面。 将此重叠标签与重叠标签一起使用。 fixed 将窗口小部件放在背景或前景上（取决于其创建位置）。 仅当还设置了重叠标志时，此标志才有效。非固定的重叠窗口可以弹出固定的窗口，而后者则不能。 enable指定是否启用窗口小部件。 启用的小部件会接收键盘和鼠标事件； 禁用的小部件则不会。 某些小部件在禁用时通常会以不同的方式显示（通常是灰色的）。 如果禁用了容器，则其内容也将被禁用。 可接受的值： 0 or no 1 or yes hidden指定小部件是否隐藏。 隐藏窗口小部件时，不会渲染该窗口小部件，但是它将占据的空间保留为空，并且不会重新布置同一容器中的其他窗口小部件。 可接受的值： 0 or no 1 or yes pos_x小部件相对于其父容器的x坐标。 仅当设置了重叠对齐标记时，此选项才生效。 pox_y小部件相对于其父容器的y坐标。 仅当设置了重叠对齐标记时，此选项才生效。 export指定是否导出对窗口小部件的引用。 如果是，则将使用使用name参数设置的名称导出小部件。 默认值为0。可接受的值： 0 or no 1 or yes 文字标签和表格有几个标签允许输出和格式化文本。 font字体标签可以嵌套，在这种情况下，所有字体属性都是继承的。 参数： face —TrueType字体文件的路径。 size 字体大小（像素） color 字体颜色 1234567&lt;label&gt; &lt;text rich=&quot;1&quot;&gt; &lt;font size=&quot;20&quot; color=&quot;#ff0000&quot;&gt;Big red text&lt;/font&gt; and text of default style.&lt;br/&gt; &lt;font face=&quot;font_other.ttf&quot; size=&quot;20&quot;&gt;You can also change font face.&lt;/font&gt;&lt;br/&gt; &lt;font color=&quot;#00ff00&quot;&gt;Here is green text with &lt;font size=&quot;10&quot;&gt;small tail.&lt;/font&gt;&lt;/font&gt; &lt;/text&gt;&lt;/label&gt; 下面这种格式也是可以的123&lt;font size=&quot;+10&quot;&gt;Larger&lt;/font&gt;&lt;font size=&quot;-4&quot;&gt;Smaller&lt;/font&gt;&lt;font size=&quot;%200&quot;&gt;Same or smaller&lt;/font&gt;大小将相对于当前字体大小进行计算。 text许多小部件和容器都有一个文本子代，该子代提供了一些格式化功能。参数： rich 标签内的文本是格式化的还是纯文本的。 默认值为0（布尔值），它对应于plain。 face TrueType字体文件的路径，默认情况下将使用。 size 默认字体大小（像素）。 color 默认字体颜色。 outline 是否应概述文字。 默认值为0（布尔值），对应于没有轮廓。 wrap 如果文本不适合容器的宽度，是否应该将文本环绕。 默认值为0（布尔值），它对应于无换行。 translate 文本是否可以翻译。 默认值为1（布尔值），这意味着文本取决于所选的语言。 如果rich参数等于1，是或是，则可以使用以下标记和实体来设置文本格式： br 划线 p 段。 aline可接受的参数：center, left, right, justify. cneter 居中对齐。 等效于文本&lt;/ center&gt;。 font 文字选项。 sub 下标文字。 sup 上标文字。 &amp;gt &gt;标志。 &amp;lt &lt;标志。 &amp;amp &amp;标志。 &amp;quot “标志。 &amp;apos ‘标志。 参考以上内容均翻译自unigine官方文档。如有错误欢迎批评指正。","categories":[{"name":"unigine引擎","slug":"unigine引擎","permalink":"https://shen-yu.gitee.io/categories/unigine%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"ui","slug":"ui","permalink":"https://shen-yu.gitee.io/tags/ui/"}]},{"title":"投影矩阵","slug":"ProjectionMatrix","date":"2020-08-30T06:00:00.000Z","updated":"2020-09-14T09:17:34.998Z","comments":true,"path":"2020/ckfdz0o4s000eai9k8o1cecxs/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4s000eai9k8o1cecxs/","excerpt":"","text":"前言显示器是2D的表面。一个3D场景必须通过投影成2D图形才能被显示。GL_PROJECTION矩阵就是用来做投影变换的。首先，我们必须把所有顶点数据从视点坐标转换到裁剪坐标，然后把裁剪坐标转换到NDC(normalized device corordinates)通过除以裁剪坐标的$w$分量。 所以，我们必须清楚裁剪和NDC转换是怎么转变成GL_PROJECTION矩阵。接下来会介绍怎么通过left,right,top,buttom, near,far六个边界值来构建矩阵的。 裁剪视锥体定义在裁剪坐标还未除以$w$之前。裁剪坐标$x_s$,$y_c$和$z_c$分别和$w_c$对比，如果大于$w_c$都会被舍弃。 -w_c < x_c, y_c, z_c < w_c当裁剪发生时，OpenGL会重构边缘的多边形。 透视投影在透视投影中，一个3D的点在截平头体（视点坐标）被映射到一个立方体（NDC);$x$的范围从$[l, r]$ 到 $[-1, 1]$,$y$的范围从$[b, t]$ 到 $[-1, 1]$,$z$的范围从$[-n, -f]$ 到 $[-1, 1]$。 视点坐标是定义在右手系的，但是NDC使用的是左手系。换句话说，在视点空间，相机在原点看向-z方向，在NDC,看向+z方向。因为glFrustum()只接受near和far的距离，我们需要消除他们在构建GL_PROJECTION矩阵。 在OpenGL中，一个3D的点会被投影到近平面。下面两幅图，展示了在视点空间里的点$(x_e, y_e, z_e)$怎么投影到近平面上$(x_p, y_p, z_p)$。 从视锥体的上方看，视点空间的x坐标，$x_e$被映射到$x_p$，可以通过相似三角形计算得到。 从视锥体的侧面看，$y_p$也是通过相同的方式映射得到： 由此可以看出$x_p$和$y_p$都取决于$z_e$，他们于$-z_e$成反比例关系。换句话说，他们都除以$-z_e$。这给我们构建GL_PROJECTION矩阵提供了帮助。在视点坐标通过GL_PROJECTION矩阵变换之后，裁剪坐标依然是齐次坐标。裁剪坐标通过除以$w_c$转换到NDC。 所以，我们设$w_c$为$-z_e$,GL_PROJECTION矩阵第四行变成$\\begin{pmatrix}0&amp;0&amp;-1&amp;0 \\end{pmatrix}$ 下一步，我们需要把$x_p$和$y_p$映射到NDC的$x_n$和$y_n$通过线性关系； [l,r]\\Rightarrow [-1, 1] [b,t]\\Rightarrow [-1, 1] 接着我们替换$x_p$和$y_p$为上方的等式。 因为透视除法$(x_c / w_c, y_c /w_c)$我们让上面两个方程都除以$-z_e$。之前我们把$w_c$设置成$-z_e$，括号里的参数就变成了裁剪坐标的$x_c$和$y_c$。 根据以上等式，我们可以得到GL_PROJECTION矩阵的第一行和第二行。 现在我们只需要求解GL_PROJECTION矩阵的第三行了。发现$z_n$和别的参数不同，因为在视点空间的$z_e$总是被投影到近平面的$-n$。但是我需要$z$来裁剪和深度测试。除此之外，我们可以将其逆变换。我们知道$z$与$x$和$y$无关。那么，借助$w$就可以发现$z_n$和$z_e$的关系。所以我们可以简化解GL_PROJECTION矩阵的第三行像这。 在视点空间，$w_e$等于1.于是方程变为 为了求解$A$和$B$，我们代入$(z_e, z_n)$关系，$(-n, -1)$和$(-f, 1)$ 解得A 解得B 最后我们得到的GL_PROJECTION矩阵 对于一个正截平头体的矩阵，宽高相等且对称： 通过观察$(z_e, z_n)$关系，深度转换时非线性的，在接近远平面精度会小，造成z-fighting 正交投影将长方体压缩成正方体，正交投影的投影矩阵$w$没必要， 视锥体是对称的，可以简化为","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"矩阵","slug":"Matrix","date":"2020-08-27T06:00:00.000Z","updated":"2020-09-05T02:19:45.089Z","comments":true,"path":"2020/ckfdz0o4m0007ai9k3wyv96a3/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4m0007ai9k3wyv96a3/","excerpt":"","text":"前言矩阵(matrix)是由$n \\ times m$个标量组成的长方形数组。矩阵便于表示线性变换（transformation)，如平移(translation)、旋转(rotation)和缩放(scaling)。在某些条件下，$4 \\times 4$矩阵可以表示任意三维变换，包括平移、旋转和缩放。这种矩阵称为变换矩阵。利用矩阵乘法可以将表示为矩阵的变换，施于点或矢量。仿射矩阵（affine matrix）是种$4 \\times 4$的变换矩阵，他能维持直线在变换前后的平行性以及相对的距离比，但是不一定维持直线在变换前后的相对长度和角度。由平移、旋转、缩放及/或切变(shear)所组合而成的变换都是仿射矩阵。 1. 矩阵乘法两矩阵$A$和$B$的积写作$P = AB$。若$A$和$B$为变换矩阵，其积$P$也是变换矩阵，而且以$P$进行变换时，等同于进行$A$和$B$两者的变换。此特性对游戏编程特别有用，因为我们可以把一连串变换预先计算为单一矩阵，在用该矩阵高效地变换大批矢量。 AB=\\begin{bmatrix} A_{11}&A_{12}&A_{13}\\\\A_{21}&A_{22}&A_{23}\\\\A_{31}&A_{32}&A_{33}\\end{bmatrix}\\begin{bmatrix} B_{11}&B_{12}&B_{13}\\\\B_{21}&B_{22}&B_{23}\\\\B_{31}&B_{32}&B_{33}\\end{bmatrix} = \\begin{bmatrix} A_{row1}B_{col1}&A_{row1}B_{col2}&A_{row1}B_{col3}\\\\A_{row2}B_{col1}&A_{row2}B_{col2}&A_{row2}B_{col3}\\\\A_{row3}B_{col1}&A_{row3}B_{col2}&A_{row3}B_{col3}\\end{bmatrix}tips：完美世界笔试题，编写矩阵乘法函数，并进行优化。123456789101112131415161718192021222324252627282930// 最朴素的矩阵乘法#include&lt;iostream&gt;using namespace std;#define SIZE_M 2#define SIZE_N 3#define SIZE_S 4 int main()&#123; int matrix_a[SIZE_M] [SIZE_N]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//a矩阵2X3 int matrix_b[SIZE_N] [SIZE_S]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;1,2,3,4&#125;&#125;;//b矩阵3X4 int matrix_result[SIZE_M][SIZE_S];//结果矩阵2X4 for(int m=0;m&lt;SIZE_M;m++)&#123; for(int s=0;s&lt;SIZE_S;s++)&#123; matrix_result[m][s]=0;//变量使用前记得初始化,否则结果具有不确定性 for(int n=0;n&lt;SIZE_N;n++)&#123; matrix_result[m][s]+=matrix_a[m][n]*matrix_b[n][s]; &#125; &#125; &#125; for(int m=0;m&lt;SIZE_M;m++)&#123; for(int s=0;s&lt;SIZE_S;s++)&#123; cout&lt;&lt;matrix_result[m][s]&lt;&lt;&quot;\\t&quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;// Stressen算法（算法导论分治策略提及）c++分析和具体实现参照一下网站https://blog.csdn.net/qq_31567335/article/details/52695144https://www.cnblogs.com/hdk1993/p/4552534.html 2. 矩阵表示点和矢量点和矢量都可以被表示为行矩阵（row matrix)$(1 \\times n)$或列矩阵(column matrix)$(n \\times 1)$，其中n表示空维度。本来可以任意选择行矢量和列矢量，但此会影响书写次序。最容易的记忆方法是，最接近矢量的矩阵会被最先进行变换。 3. 单位矩阵单位矩阵(identity matrix)是指，它乘以任何其他矩阵，都会得到和原来一样的矩阵。单位矩阵写作$I$。单位矩阵是正方形矩阵，对角线上的元素皆为1，其他元素为0： 4. 逆矩阵矩阵A的逆矩阵(inverse matrix)(写作$A^{-1}$)能还原矩阵$A$的变换。一个矩阵乘以它的逆矩阵，结果必然是单位矩阵，因此$A(A^{-1}) = (A^{-1})A = I$。并非所有的矩阵都有逆矩阵。然而，所以仿射矩阵(纯平移，选择，缩放及切变的组合)都有逆矩阵。若矩阵的逆矩阵存在，可以高斯消去法(Gaussian eliminaton)或LU分解(LU decomposition)求之。 5. 转置矩阵矩阵$M$的转置(transpose)写作$M^{T}$。转置矩阵就是把原来的矩阵以主对角线(diagonal)为对称轴做反射。原矩阵：转置后： 基于以下两个原因，转置矩阵很实用。首先，标准正交矩阵(纯旋转)的逆矩阵和转置矩阵是一样的—此特性非常好，因为计算转置矩阵比计算一般逆矩阵快很多；其次，当把数据从一个数学程序库送到另一个程序库时，转置矩阵也十分重要，因为有些库使用行矢量，有些则使用列矢量 6. 齐次坐标(homogeneous coordinates）由于3维种旋转是由3X3矩阵表示，但是平移无法由3X3矩阵表示，那么我们则无法将仿射变换通过矩阵乘法叠加，但是我们可以将平移使用4X4矩阵来表示。齐次坐标的作用，把各种变换都统一了起来，即 把缩放，旋转，平移等变换都统一起来，都表示成一连串的矩阵相乘的形式。保证了形式上的线性一致性。 除此之外，在数学上，点（位置矢量）和方向矢量的处理方法有细微差异，当用矩阵变换一个点时，平移，旋转，缩放，都会施加于该点上。但是，当用矩阵变换一个方向矢量时，就要忽略矩阵的平移效果。因为方向矢量本身并无平移，加上平移会改变其模，这并非我们想要的。在齐次坐标中，可以将点的w分量设为1，而把方向矢量的w分量设为0。以下的例子显示，矢量v中的w = 0, 因此乘以矩阵的t矢量后，可在结果中消去平移的作用: 严格来说，（四维的）齐次坐标转换成（三维的）非齐次坐标的方法是，把x, y ,z分量除以w分量：此公式表明，可设点的w分量为1，方向矢量为0。矢量除以w=1,并不影响点的坐标，但是矢量除以w=0则会产生无穷大(infinity)。四维中位于无穷远的一点，可以旋转但不可以平移，因为无论怎么平移，该点还是位于无穷远。所以事实上，三维空间的纯方向矢量在四维齐次空间中则是无穷远的点。 7. 基础变换坐标任何仿射变换矩阵都能由一连串表示纯平移，纯旋转，纯缩放及/或纯切变的4X4矩阵串接而成。4X4变换矩阵可切割成4个组成部分： 左上角的3 X 3矩阵U，代表旋转及/或缩放。 1 X 3平移矢量t 3 X 1零矢量$0 = [ 0 0 0]^{T}$。 矩阵右下角的标量1。 当一点乘如此切割的矩阵时，结果会是： 7.1 平移或可写成切割后的缩写： 为求纯平移变换矩阵的逆矩阵，只需要t求反(negate)。 7.2旋转所有4 X 4纯旋转变换矩阵都是如下形式：矢量t为0，而左上角的3 X 3矩阵R则包含旋转角度（弧度单位）的余弦和正弦。 7.3 缩放以下的矩阵缩放点r,向x轴的缩放因子为$s_x$，向y轴的为$s_y$，向z轴为$s_z$：或可写成切割后的缩写： \\begin{bmatrix} r&1\\end{bmatrix} \\begin{bmatrix} S_{3 \\times 3}&0\\\\0&1\\end{bmatrix} = \\begin{bmatrix} rS_{3 \\times 3}&1\\end{bmatrix}8. 4 X 3矩阵4 X 4仿射矩阵的最右侧必然是一列[0 0 0 1]T的矢量。因此，游戏程序员可略去第4列，以节省内存。在游戏数学库里经常会遇到4X3仿射矩阵。在使用GPU做蒙皮(skinning)时，要向顶点着色器(vertex shader)传递大量的变换，所以为节省空间、时间，通常会使用4X3的矩阵。 9. 坐标空间在物理学中，一组坐标轴代表参考系（frame of reference），所以有时候又会称一组坐标轴为坐标系(coordinate frame，简称为frame)。游戏业界会使用坐标空间(coordinate space)一词，或简称空间(space)，来表示一组坐标轴。以下讨论游戏和计算机图形学中几个较为常用的空间坐标。 9.1 模型空间当使用Maya或3ds Max之类的工具去建立三角形网格时，三角形顶点的位置是相对于一个笛卡儿坐标系的，我们称此坐标系为模型空间(model space)，也可以称之为物体空间(object space)或局部空间(local space)。模型空间的原点可置于物体的中心位置，如物体的质心(center of mass)，对于人形及动物着色，可把模型空间的原点置于足部和地面之间。 9.2 世界空间世界空间(world space)是一个固定的坐标空间。游戏世界中所以物体的位置、定向和缩放都会用此空间表示。此坐标空间把所有单个物体联系在一起，形成一个内聚的虚拟世界。 9.3 观察空间观察空间(view space)又称为摄像机空间(camera space),是固定在摄像机的坐标系。观察空间原点置于摄像机的焦点（focal point)。而且，观察空间也可采用不同的轴定向方案。但是，y轴向上、z轴顺着摄像机面对方向，是最典型的，因为+z轴代表着屏幕的深度。其他引擎和API(如OpenGL)做用右手系定义观察空间，使摄像机朝向的方向为-z轴，z坐标代表负深度。 10. 基的更变在游戏和计算机图形学里，经常把物体的位置、定向和缩放从某个坐标系转换为另一个坐标系。我们称此为基的变更(change of basis)。 10.1 坐标空间的层次结构坐标系是相对的。即若想在三维空间中定义一组轴，必须指明其位置、定向和缩放的数值是相对于另外一组轴的（否则那些数值是没意义的）。这意味着，坐标空间会形成一个层阶结构—每个坐标空间都是某个坐标空间之子，而那个坐标空间则是父的角色。世界空间并无父，因为他是坐标空间树的根，其他坐标空间则直接或间接地相对于世界空间。 10.2 构建改变基的矩阵把点和方向从任何子坐标系C变换至其父坐标系P的矩阵，可写作$M_{C \\rightarrow P}$ 。此下标表示矩阵把点和方向从子空间变换至父空间。以下等式可把任何子空间位置矢量$P_C$变换至父空间位置矢量$P_C$: P_P = P_CM_{C \\rightarrow P}以上等式中： $i_C$为子空间x轴的单位基矢量，此矢量以父空间坐标来表示。 $j_C$为子空间y轴的单位基矢量，此矢量以父空间坐标来表示。 $k_C$为子空间z轴的单位基矢量，此矢量以父空间坐标来表示。 $t_C$为子坐标系相对于父坐标系的平移。 缩放子轴 通过简单且恰当的缩放单位基矢量，便可以缩放子坐标系统。例如，若子空间放大两倍，则基矢量$i_C, j_C, k_C$就由单位长度变为长度为2。 10.3 从矩阵中获取单位基矢量由于基变更矩阵是由平移及三个笛卡儿基矢量组成的，此事实可带来一个强大工具：给定任何4X4仿射矩阵，都可以用反向思维，从恰当的矩阵行(若是由列矢量则为矩阵列)中获取子空间基矢量$i_C,j_C,k_C$。 10.4 变换坐标系还是矢量若基于坐标轴来思考，变换会是某一个方向；若基于点和坐标来思考，变换则是另一个方向！ 11. 变换法矢量法矢量是一种特殊的矢量，因为它除了是单位矢量（通常情况是）外，法矢量还有附加要求—维持与对应的表面或平面垂直。变换法矢量必须特别留心，以确保维持其长度和垂直性。一般情况下，为了保证即使变换里含非统一缩放或切变；变换后的法矢量仍然垂直于其对应表面，需要对方矢量做仿射矩阵的逆转置矩阵做变换$(M_{A \\rightarrow B}^{-1})^T$。从另一个角度看，这里需要逆转置是因为表面矢量是赝矢量，不是普通矢量。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"点和矢量","slug":"pointAndVecotr","date":"2020-08-23T06:00:00.000Z","updated":"2020-09-05T01:17:06.923Z","comments":true,"path":"2020/ckfdz0o5q002nai9k2gca4z9g/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5q002nai9k2gca4z9g/","excerpt":"","text":"前言大部分现代3D游戏都是由虚拟世界里的三位物体组成的。游戏引擎的位置（position)、定向(orientation)和比例(scale)，不断改变这些属性以产生动画，并把这些属性变换(transform)至屏幕空间,使物体能被渲染到屏幕上。在游戏中，三维物体几乎都是由三角形组成的，其中三角形的顶点（vertex）则以点(point)表示。所以学习怎样表示游戏的整个对象之前，我们先来了解一下点，以及与之关系密切的矢量。 1 点与笛卡儿坐标严格地说，点是n维空间的一个位置(在游戏中，n通常等于2或3)。笛卡儿坐标系（Cartesian coordinate system) 是游戏程序员最常用的坐标系，它使用2个或3个相互垂直的轴来描述二维或三维空间的位置。因此，可以由2个或3个实数表示一个点P，即$（P_x，P_y）$或$（P_x，P_y， P_z）$。 除了笛卡儿坐标系之外，还有圆柱坐标系(cylindrical coordinate system),球坐标系（spherical coordinate system)。Crack the Weasal中就为了使得类似漩涡的效果更好实现就是用了圆柱坐标系。 2 左手坐标系和右手坐标系的比较在三维笛卡儿坐标中，要安排3个相互垂直的轴，我们有两种选择，右手（right-handed RH)和左手(left_handed LH)。要掌握右手坐标系3个轴的方向，可把右手握拳，伸出拇指指向x轴，食指指向y轴，中指指向z轴。左手系则使用左手。左手坐标与右手坐标的区别在于3个轴其中一个轴的方向不同。左手和右手坐标系相互转换十分容易。只需把其中一个轴反转，并保留另外两个轴不变即可。非常重要的是，数学法则在左手和右手坐标系里并不会改变，改变的只是我们如何把这些数学在脑海里诠释为三维空间。 3 矢量矢量(vector)是指n维空间中包含模（magnitude）和方向的量，矢量可绘制成有向线段，线段自一点（尾）延伸至另一点（头）。矢量和标量(scalar)（即普通的实数数值）比较，标量有模但没有方向。 三维矢量可以用3个标量(x,y,z)表示，如同点一样。点和矢量的区别实际上是很细微的。严格地说，矢量是相对于某已知点的偏移。一个矢量可移至三维空间中的任何位置，只要该矢量的方向和大小保持不变，无论在哪个位置，皆为同一个矢量。 矢量也可以用来表示点，只要把其尾固定在坐标系的原点（origin)。这些矢量有时候被称为位置矢量（position vector）或矢径（radius vector）。对我们来说，可以把3个标量视为点或矢量，只要记住，位置矢量的尾固定于已选坐标系的原点便可。这意味着，数学上点和矢量在使用时有微妙区别。或者说，点时绝对的，而矢量是相对的。 4 矢量运算4.1 矢量和标量的乘法矢量a和标量s相乘，等于a的每个分量和s相乘： sa = \\begin{bmatrix}sa_x&sa_y&sa_z \\end{bmatrix}4.2 矢量加减法a+b=\\begin{bmatrix}(a_x+b_x)&(a_y+b_y)&(a_z+b_z) \\end{bmatrix}a-b=\\begin{bmatrix}(a_x-b_x)&(a_y-b_y)&(a_z-b_z) \\end{bmatrix}4.3 矢量模|a| = \\sqrt{a_x^2 + a_y^2 + a_z^2}4.4 矢量运算的简单应用矢量加法，应用于角色或物体移动，初始位置加偏移量得到现在位置。显示欧拉法求解弹簧质点系统就是使用这个。矢量减法，判断两球体是否相交，两球心的位置矢量相减得到的矢量的模与两球半径之和进行比较。tips:开方的操作比较费时，模的平方有时候十分有效。 4.5 归一化和单位矢量单位矢量(unit vector)是模（长度）为1的矢量。 给定任意矢量$v$的长度$v=|v|$,可以把该矢量转换为单位矢量$u$，使其保持$v$的方向不变，长度为单位长度。用$v$乘以其模的倒数（reciprocal）。此过程叫做归一化(normalization)。 4.6 法矢量某表面（surface)的法矢量（normal vector)是指某矢量垂直于该表面。法矢量在游戏和计算机图形学中非常有用。例如，一个平面(plane)可用一个点和一个法矢量来定义。在三维图形中，经常大量使用法矢量计算光线和材质表面之间的夹角。 4.7 点积和投影矢量间可以相乘，但和标量不同，矢量有多种乘法。在游戏编程中，最常用的有两种： 点积(dot product)， 又称为标量积(scalar product)或内积(inner product)。 叉积(cross product),又称为矢量积(vector product)或外积(outer product). 两个矢量的点积结果是一个标量，此标量定义为两个矢量中每对分量乘积之和： a·b = a_xb_x + a_yb_y + a_zb_z = d(一个标量)点积也可以写成两个矢量的模相乘后，在乘以两个矢量间夹角的余弦值： a·b =|a||b|cos\\theta点积可进行交换律(communitative)运算，以及在加法上也可进行分配律(distributive)运算，也可结合标量乘法。 点积的主要用法：1.矢量投影，任意向量$a$与单位向量$u$点乘，得到向量$a$在$u$上的投影2.点积求模，两个相同向量点积，得到模的平方3.点积判定，用来判断两矢量是否共线，是否同向，是否反向，是否垂直。4.在游戏里，或用点积来判断敌人是否在你的前面，敌人位置减玩家位置与玩家的前向方向相乘 4.7 叉积向量积，数学中又称外积、叉积，物理中称矢积、叉乘，是一种在向量空间中向量的二元运算。与点积不同，它的运算结果是一个向量而不是一个标量。并且两个向量的叉积与这两个向量和垂直。其应用也十分广泛，通常应用于物理学光学和计算机图形学中。 模长：（在这里$\\theta$表示两向量之间的夹角（共起点的前提下）$（0°≤\\theta≤180°）$，它位于这两个矢量所定义的平面上。）方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。）也可以这样定义（等效）：向量积$|c|=|a \\times b|=|a||b|sin\\theta$即c的长度在数值上等于以a，b，夹角为θ组成的平行四边形的面积。而c的方向垂直于a与b所决定的平面，c的指向按右手定则从a转向b来确定。*运算结果c是一个伪向量。这是因为在不同的坐标系中c可能不同 叉积的主要用法：1.求解平面法矢量，用平面内三点构成两个不平行的矢量，叉积得到法矢量。2.在物理模拟中要来求解力矩3.求解三角形面积4.判断点是否在三角形内5.判断两个矢量的左右关系和是否共线 12345678910111213141516// GAMES101 判断点是否在三角形内static bool insideTriangle(float x, float y, const Vector3f* _v)&#123; // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2] Eigen::Vector2f v1(_v[0].x(),_v[0].y()); Eigen::Vector2f v2( _v[1].x(),_v[1].y()); Eigen::Vector2f v3(_v[2].x(),_v[2].y()); float s = (v2.x() - v1.x()) * (v3.y() - v1.y()) - (v2.y() - v1.y()) * (v3.x() - v1.x()); float s1 = (v2.x() - v1.x()) * (y - v1.y()) - (v2.y() - v1.y()) * (x - v1.x()); float s2 = (v1.x() - v3.x()) * (y - v3.y()) - (v1.y() - v3.y()) * (x - v3.x()); float s3 = (v3.x() - v2.x()) * (y - v3.y()) - (v3.y() - v2.y()) * (x - v3.x()); return ((s*s1) &gt; 0&amp;&amp;(s*s2)&gt;0&amp;&amp;(s*s3)&gt;0);&#125; 5 点和矢量的线性插值游戏中，时常要找出两个已知矢量之间的矢量。例如，要在两秒内，以每秒30帧的速度，用动画形式顺滑地把物体从$A$点移动到$B$点，那么须计算A和B之间60个中间点（intermediate point）。 线性插值（liear interpolation) 是一个简单的数学运算，用来计算两个已知点点中间点。此运算的名称通常简写成LERP。此运算定义如下，其中$\\beta $介于并包含0～1: L=LERP(A,B,\\beta) = (1-\\beta)A+\\beta B从几何上看，$L=LERP(A,B,\\beta)$为AB线段间一点的位置矢量，该点距A点b百分比的位置。数学上，LERP函数只是两矢量的加权平均（weighted average)。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"贪心算法","slug":"greedy","date":"2020-08-20T06:00:00.000Z","updated":"2020-09-02T15:06:50.189Z","comments":true,"path":"2020/ckfdz0o5a001eai9kdvy006rq/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5a001eai9kdvy006rq/","excerpt":"","text":"贪心算法VS动态规划由于贪心和动态规划都利用了最优子结构性质，你可能会对一个可用贪心求解的问题设计一个动态规划算法，或者相反，对于一个实际上需要动态规划求解的问题使用了贪心算法。为了说明两种方法之间的细微差别，我们研究一个经典最优化问题的变形。 0-1背包问题一个正在抢劫商店的小偷发现了n个商品，第i个商品价值vi美元，重wi磅，vi和wi都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多容纳W磅重的商品，W是一个整数。他应该拿哪些商品呢？（我们称这个问题是0-1背包问题，因为对每个商品，小偷要么把它完整拿走，要么把它留下；他不能只拿走一个商品的一部分。或者把一个商品拿走多次。） 分数背包设定与0-1背包问题是一样的，但对每个商品，小偷可以拿走其一部分，而不是作出二元（0-1）选择。你可以将0-1背包想象为金锭，而分数背包问题中的商品更像金砂。 比较两个问题都有最优子结构性质，对于0-1背包问题，考虑重量不超过W而价值最高的装包方案。如果我们将商品j从此方案中删除，则剩余商品必须是重量不超过W-wi的价值最高方案（小偷只能从不包括商品j的n-1个商品中选择拿走哪些）。虽然两个问题相似，但我们可以用贪心策略求解分数背包问题，而不能求解0-1背包问题。为了求解分数背包问题，我们首先计算每个商品的每磅价值vi/wi。遵循贪心策略，小偷尽可能地拿走每磅价值最高的商品。如果该商品已全部拿走而背包未装满，他继续选择拿走商品第二高的商品，依此类推，直到上限达到W。 贪心算法原理贪心算法通过做出一系列选择来求解问题的最优解。在每个决策点，它做出在当时看来最佳的选择。这种启发式策略并不保证总能找到最优解，但对于有些问题确实有效，如活动选择问题。设计贪心步骤算法： 1.将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个问题需要求解。 2.证明做出贪心选择后，原问题存在最优解，即贪心选择总是安全的。 3.证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。 贪心小技巧1.通过对输入进行预处理或者使用适合的数据结构（通常是优先队列），我们通常可以使贪心选择更加快速，从而得到更高效的算法。2.当应用贪心算法时，我们通常使用更为直接的最优子结构。如前所述，我们可以假定，通过对原问题应用贪心选择即可得到子问题。我们真正要做的全部工作就是论证：将子问题的最优解与贪心选择组合在一起就能生成原问题的最优解。这种方法隐含地对子问题使用了数学归纳法，证明了在每个步骤进行贪心选择会生成原问题的最优解。 贪心例题及参考活动安排，哈夫曼编码，小船过河，找零问题，最小完成时间调度，无环子图例题合集：https://www.cnblogs.com/hust-chen/p/8646009.html","categories":[{"name":"算法","slug":"算法","permalink":"https://shen-yu.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://shen-yu.gitee.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"动态规划","slug":"dynamicProgramming","date":"2020-08-17T06:00:00.000Z","updated":"2020-09-01T14:44:38.942Z","comments":true,"path":"2020/ckfdz0o4y000pai9ka1ty44w9/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4y000pai9ka1ty44w9/","excerpt":"","text":"动态规划与分治算法比较分治算法将问题分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其分为更小的子子问题）。这种情况下，分治算法会做许多不必要的工作，它会反复求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。 求解问题类型动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到寻找具有最优化（最大值或最小值）的解。我们称这样的解为问题的一个最优解，而不是最优解，因为可能有很多个解都能达到最优值。 基本步骤 刻画一个最优解的结构特征 递归的定义最优解的值 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解 步骤1~3是动态规划算法求解问题的基础。如果我们仅仅需要维护一个最优解的值，而非解本身，可以忽略步骤4。如果确实需要做步骤4，有时就需要在执行步骤3的过程中维护一些额外信息，以便用来构造一个最优解。 动态规划例题背包问题：https://anivian.github.io/pack-master/V2.pdf寻路问题：https://www.cnblogs.com/hapjin/p/5705319.html最优矩阵链乘：https://blog.csdn.net/zhangxb35/article/details/38959047","categories":[{"name":"算法","slug":"算法","permalink":"https://shen-yu.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://shen-yu.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"雷火引擎一面二面","slug":"interview_163_leihuo","date":"2020-08-13T06:00:00.000Z","updated":"2020-08-14T15:05:23.556Z","comments":true,"path":"2020/ckfdz0o59001cai9k0p1jcaw2/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o59001cai9k0p1jcaw2/","excerpt":"","text":"前言参加完OpenDay热血澎湃。早上网易mini游戏展，堪比ChinaJoy的模式，就是比较小型。但是整个游戏来说大部分可能还是Demon的形式，但是总体制作还是比较精良的。有一种参加学校社团展示的感觉，每个人都很热血。下午，动作捕捉中心和lua编写AI脚本。体验拉满。第二天刚好面试，还沉浸OpenDay的欢乐之中。 一面手写了五道题目主要考察虚函数，数学知识和算法 10个数二分查找失败查找几次 入射方向L, 法线N，求反射R 哪些可以是虚函数 虚函数 左值右值 排序算法有哪些 归并排序怎么实现，主要思想 反问面试官 询问了雷火的主要产品和收益情况？主要收益来自逆水寒和倩女幽魂 询问了unity和unreal的学习问题？unity容易上手，unreal上手相对会难一点。 二面是昨天mini项目的导师 自我介绍 看到我也学了GAMES101，询问GAMES101学到了什么，和别的有什么不同 考察两个数学题 ，光线反射， 给定一个点和面求交点 询问项目，想查看项目的具体展示，项目的实际问题，解决方案 询问了笔试时小王打字那个题目 动态规划的基本思想 简单手写了前序遍历 反问面试官 引擎的各种子系统会有哪些？推荐了《游戏引擎架构》，可以作为扫盲书。 举例了雷火主要使用unity，腾讯主要使用unreal,推荐去自己熟悉操作一下引擎，尝试跑一些例子。 好心建议就是离引擎的水平还是有一定差距，客户端还是可以继续三面，主要看你个人意愿。我现在做的就是我自己热爱的东西。所以。。。。公司相对会更愿意招一个能掌握最近资讯和技术的人，节约了培养成本。 后记整体感觉都很好，面试交流也比较融洽，在面试的过程中还是能学到很多东西，如果学习路线该怎么走，履历该怎么增加等等，面试官无疑是最好的学习指导，以为他知道他想要什么，你就从他想要的东西里看看自己缺少什么。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"网易互联网笔试","slug":"exam_163_internet","date":"2020-08-08T06:00:00.000Z","updated":"2020-08-12T15:07:29.851Z","comments":true,"path":"2020/ckfdz0o51000xai9kaidv79x2/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o51000xai9kaidv79x2/","excerpt":"","text":"前言中午被麻辣香锅搞得死去活来，下午被网易笔试搞得死去活来。四道题AC1.25,第三题没看，第四题是强连通量，关于图的题目是我的薄弱，得去花些时间看看。 第一题 回文串给定一个长度为n(n&lt;=1e3)的字符串，可以在后面加无限多的字母，问能组成的最短回文串是多长？解法一：注意到n比较小，直接暴力解法二：可以用manachar算法，算出原串最长回文后缀的长度，然后就可以得到最短的字符串了。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;bool check(string &amp;s, int start, int end) &#123; int i = start, j = end; while (i &lt; j &amp;&amp; s[i] == s[j]) &#123; ++i, --j; &#125; return i &gt;= j;&#125;int main() &#123; string s; cin &gt;&gt; s; int length = s.size(); for (int i = 0; i &lt; length; ++i) &#123; if (check(s, i, length - 1)) &#123; break; &#125; &#125; string prefix = s.substr(0, i); reverse(prefix.begin(), prefix.end()); cout &lt;&lt; s + prefix &lt;&lt; endl; return 0;&#125; 第二题 物品价值现在有n个物品，每个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人分到的物品价值总和相同(个数可以不同，总价值相同即可)，剩下的物品就要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。输入： 第一行输入一个整数T，代表有T组测试数据 对于每一组测试数据，一行输入一个整数n，代表物品的个数 接下来n个数，a[i]代表每一个物品的价值 1 &lt;= T &lt;= 10 1 &lt;= n &lt;= 15 1 &lt;= a[i] &lt;= 100000输出： 每一行输出最少需要扔掉多少价值的物品 示例：输入1530 60 5 15 30输出20 说明样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每个人分到的价值为60，扔掉的价值为20。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int siz=1500000;int a[20],dp[siz+5];int main()&#123; int T, n, i, j, ans, sum; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; sum = 0; for (i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (i = 0; i &lt; n; ++i)&#123; for (j = sum; j &gt;= a[i]; --j) dp[j] = dp[j] | dp[j-a[i]]; &#125; ans = sum; for (i = sum; i &gt;= 0; --i) &#123; if( i % 2 != 0) continue; if(dp[i] &amp;&amp; dp[i/2]) &#123; ans = sum - i; break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 第三题 排队买票题目描述n(n&lt;=2000)个人排队买票，第i个人要么单独买票，要么和后面一个人一起买（反过来，就是可以和前面一个人买），单独买花费时间a[i]，一起买是b[i]，求所有人买完票的最短时间。开始时间是早上08:00:00 am，输出结束时间。 分析动态规划，dp[i]表示第i个人买完票所需要的时间。对于每一个人他可以有两个选择，要么单独买票，那么需要的总的时间就是dp[i-1] + a[i]，要么和前一个人一起买票，需要的总的时间就是dp[i-2] + b[i]。最后输出的时候注意格式。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int a[2222], b[2222];int dp[2222];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n; ++i) cin &gt;&gt; a[i]; for (int i = 2; i &lt;= n; ++i) cin &gt;&gt; b[i]; memset(dp, 0, sizeof(dp)); dp[0] = 0, dp[1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = min(dp[i - 1] + a[i], dp[i - 2] + b[i]); &#125; int hour = dp[n] / 3600 + 8; int minutes = dp[n] % 3600 / 60; int seconds = dp[n] % 3600 % 60; printf(&quot;%02d:%02d:%02d &quot;, hour, minutes, seconds); puts(hour &lt;= 12 ? &quot;am&quot; : &quot;pm&quot;); return 0;&#125; 第四题 相互认可题目描述a教授认可b教授，b教授认可c教授，那么a也认可c。现有n (小于50000)个教授，m（小于600000）个认可，可能自己认可自己，也可能重复。求互相认可的教授有多少对？分析学过强联通分量的应该可以一下子看出来这个就是要求强联通分量，每个强联通分量里的所有教授都是互相认可的。。没学过的话可以尝试暴力解解。 思考如果改变下条件，只要a认可b，那么b就默认认可a，这个时候求互相认可的教授有多少对该怎么算呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 555;#define ll long longint low[maxn], num[maxn], dfn, cnt;ll ans;int sccno[maxn];stack&lt;int&gt; st;vector&lt;int&gt; G[maxn];void dfs(int u) &#123; st.push(u); low[u] = num[u] = ++dfn; for (int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if (!num[v])&#123; dfs(v); low[u] = min(low[u], low[v]); &#125; else if (!sccno[v]) &#123; low[u] = min(low[u], num[v]); &#125; &#125; if (low[u] == num[u]) &#123; cnt++; int tmp = 0; while(true) &#123; int v = st.top(); st.pop(); tmp++; sccno[v] = cnt; if (u == v) break; &#125; ans += tmp * (tmp - 1) / 2; &#125;&#125;void tarjan(int n) &#123; cnt = dfn = 0; ans = 0; memset(sccno, 0, sizeof(sccno)); memset(low, 0, sizeof(low)); memset(num, 0, sizeof(num)); for (int i = 1; i &lt;= n; ++i) &#123; if (!num[i]) dfs(i); &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); &#125; tarjan(n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记可能还是得多花些时间在刷题上，在这参加的四五次笔试中,目标还是得冲击AC3.0 4AC可能有点难， 下次可能还是得自己找四道题，然后花2小时看看能做多少。 内容部分摘抄自公众号：https://mp.weixin.qq.com/s?__biz=MzI5MDA4ODczOA==&amp;mid=2648028133&amp;idx=1&amp;sn=4c819b2b17cb50aa40855468f7e2ef88&amp;chksm=f40421a8c373a8bed46bad37341a5c7b9c0f8c5a1d441774b3cfdfd6c5d9fe7bba213605c31c&amp;scene=158#rd","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"网易互娱图形开发工程师sp","slug":"interview_163_huyu","date":"2020-08-04T06:00:00.000Z","updated":"2020-08-05T04:42:26.562Z","comments":true,"path":"2020/ckfdz0o5b001iai9k1npago4d/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5b001iai9k1npago4d/","excerpt":"","text":"前言在面试之前，特地去网易互娱校招官网查看了图形开发工程师的职位描述和要求。 以下复制一下 职位要求1234567891011121314您可以：- 负责游戏产品的视觉效果，实现各种酷炫的效果，让所有平台和设备的玩家都有同样震撼的游戏体验；- 负责游戏产品的图形部分相关开发； - 与美术协作实现各种高级视觉效果，并优化content pipeline。任职资格我们希望您具备以下条件：- 计算机视觉或图形学等相关研究方向；- 有扎实的c++基础；- 有良好的图形学和数学基础；- 至少熟悉DirectX、OpenGL、Metal或者Vulkan中的一种图形API，并有很强的shader编写能力；- 熟悉AAA级游戏中常见的渲染技术，并对某一领域有深入理解，比如全局光照、粒子、材质表现、性能优化；- 有一定debug和性能分析能力。备注：广州需求80，杭州需求15，上海需求25。 当看到熟悉AAA级游戏中的渲染技术，对某一领域有深入理解。内心就频频发虚。看了看杭州需求15人，基本也没有我的什么机会了。但是，面试就是抱试试水的心态，一探虚实。 预约14：30面试，可能是面试官来不及安排，所以安排我们手撕了一道简单的算法题。 试前代码题目：区间合并（leetcode 56题原题）给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].示例2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-intervals著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解（自己花了15分钟写出来，这里复制官方题解，清晰明了方便日后学习）12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if (intervals.size() == 0) &#123; return &#123;&#125;; &#125; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; merged; for (int i = 0; i &lt; intervals.size(); ++i) &#123; int L = intervals[i][0], R = intervals[i][1]; if (!merged.size() || merged.back()[1] &lt; L) &#123; merged.push_back(&#123;L, R&#125;); &#125; else &#123; merged.back()[1] = max(merged.back()[1], R); &#125; &#125; return merged; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 面试刷完笔试题后，15分钟看着电脑屏幕里的自己，不敢玩手机，怕被误认为作弊，也不管浏览网页，就这样傻傻的看着自己。 15：00面试官来了。 相比较字节和华为的面试官，网易的这位面试官发量明显稀少了很多。 开篇：先做个简单的自我介绍，知识点考察主要分为c++和图形学相关知识 c++ 你知道程序由于异常退出，导致资源无法释放。这样的问题有什么解决方案么？（主要考察智能指针） 由智能指针出发询问你是否知道RAII？ 考察了为什么要引入move new和molloc的区别 vector和list遍历一遍谁比较快 map和unordered_map的区别和使用场景 你对多线程有了解么 虚函数的考察：构造函数调用虚函数 字节面试官也问了(https://blog.csdn.net/songchuwang1868/article/details/96481853) 图形学 这个渲染管线的流程 顶点着色器完成了什么 光栅化完成了什么 混合和测试完成了什么 用于加速光线追踪的算法 阴影的算法 描述一个算法如何实现只将你看到的内容加载，没看到的内容就不加载 回马枪笔试考察了一下纸牌排序random_shuffle, 查了一下这个是stl的内部函数12345678910template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt; void random_shuffle (RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; gen)&#123; iterator_traits&lt;RandomAccessIterator&gt;::difference_type i, n; n = (last-first); for (i=n-1; i&gt;0; --i) &#123; swap (first[i],first[gen(i+1)]); &#125;&#125; 反问面试官 询问了RAII的意思 询问了图形开发工程师和引擎开发工程师， 图形可能会更偏向渲染这一块， 引擎更偏向物理引擎这一块。 后记GAMES101更偏向讲rendering偏向图形开发， GAMES201更偏向讲物理引擎和数值计算偏向与引擎。但是GAMES201难度比GAMES101高多了，有时间还是得去复习一下GAMES101的内容如果想面试图形开发工程师的话，当然，多线程编程也需要去学习和弄个小项目自己玩玩。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"网易雷火游戏研发笔试","slug":"exam_163","date":"2020-08-02T06:00:00.000Z","updated":"2020-08-03T13:01:25.538Z","comments":true,"path":"2020/ckfdz0o520010ai9kfm8b7uev/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o520010ai9kfm8b7uev/","excerpt":"","text":"前言最近，可能是投的岗位有点多，所以就收到各种笔试和面试通知，静下心来准备面试的时间开始变得琐碎了。对于具体的职业发展方向开始有点踌躇。无论选择哪个方向都是还有一堆的东西等着你去补。对于网易3个小时的笔试，4道编程题，时间依旧是十分紧张。在上次阿里笔试看了别的大佬AC的代码简洁清晰，这可能就是和那些ACMer的差距，比较人家的代码量是你的几十倍。网易还有一个特别的地方就是不允许使用本地IDE。四道题的题目分值不同，分别是10，20，30，40。总分100。 第一题 完全二叉树的翻转 10分输入n, mn表示完全二叉树的层数m表示需要进行翻转的节点翻转：该节点的左右子树进行交换 输入 输出 1 1 /\\ /\\ 2 3 2 3 /\\ /\\ /\\ /\\ 4 5 6 7 4 5 7 6 /\\ /\\ /\\ /\\ /\\ /\\ /\\ /\\ 8 9 10 11 12 13 14 15 8 9 10 11 14 15 12 13 输入：4 3输出：123457689101114151213 题解(AC)12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public:// 递归也可以用队列来代替， 递归写法简单，在时间通过的情况下可以选择递归 void dfs(vector&lt;int&gt; &amp;arr, int left, int right) &#123; if (left &gt; arr.size() - 1 || right &gt; arr.size() - 1) &#123; return; &#125; else &#123; // 左边遍历左子树， 右边遍历右子树 dfs(arr, 2 * left, 2 * right); dfs(arr, 2 * left + 1, 2 * right + 1); swap(arr[left], arr[right]); &#125; return; &#125;&#125;;int main() &#123; Solution s = Solution(); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int size = 1 &lt;&lt; n; vector&lt;int&gt; arr(size, -1); for (int i = 1; i &lt; size; i++) &#123; arr[i] = i; &#125; s.dfs(arr, 2 * m, 2 * m + 1); for (int i = 1; i &lt; size; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 第二题 福袋问题（20分）第一行输入N，K，其中N代表有多少种商品,K代表每个福袋要包含K种不同的物品。第二行输入N个整数表示，每种商品的数量 要求输出最多能凑成多少个福袋。输入：5 31 2 3 4 5输出：5商品组合： 商品1 商品2 商品3 商品4 商品5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 共计A1 B:2 C:3 D:4 E:5 题解 (AC 90%, 具体对一些N和K的限制条件忘了)12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, k; while (cin &gt;&gt; n &gt;&gt; k) &#123; vector&lt;int&gt; arr(n, -1); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ans = 0; sort(arr.begin(), arr.end());// 商品不足K则结束 while (arr[n - k]) &#123; ans += arr[n - k]; for (int i = 1; i &lt;= k; i++) &#123; arr[n - i] -= arr[n - k]; &#125; sort(arr.begin(), arr.end()); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 第三题 打字问题 (30分)输入N，N表示需要打的字数，输出 打出至少N个字，需要的最少按键数。 基本操作：操作1： X：没有选中内容，在当前位置输入X，如有选中内容，替换选中内容为X。按键数为1。操作2： CTRL + A :选中全部内容。按键数为2。操作3： CTRL + C :更新粘贴板的内容为选中内容， 初始时粘贴板为空。按键数为2。操作4: CTRL + V :复制粘贴板的内容输出。按键数为2。操作5： ESC:取消当前选中状态。按键数为1 输入;100 输出：29 操作 键数 字数 X 7键 7 CTRL + A 9键 7 CTRL + C 11键 7 ESC 12键 7 CTRL + V 14键 14 CTRL + V 16键 21 CTRL + V 18键 28 CTRL + A 20键 28 CTRL + C 22键 28 ESC 23键 28 CTRL + V 25键 56 CTRL + V 27键 84 CTRL + V 29键 112 思路①第一种情况在输入了i个字符的基础上，再输入10-i个，(i为从1到9)； ②第二种情况：输入了i个字符后，我复制这i个字符，取消选择，然后在后面进行多次粘贴，这里的i可以从1到10/2；循环取i，求最小值，需要注意的是，当10%i不为0时，需要再加上F(10%i)； ③第三种情况：输入了i个字符后，我还是复制粘贴这i个字符，但是上面②是复制之后，取消选择，在原来的后面继续粘贴；这里我复制之后，输入一个字符，将原来输入的都覆盖掉，然后再粘贴； 题解 (选自牛客ShareLe https://blog.nowcoder.net/n/d43c430ce1434432862efc6f05513fbf)12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N; while (cin &gt;&gt; N) &#123; vector&lt;int&gt; dp(N + 1, 99999); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) dp[i] = min(dp[i], dp[i - j] + j); //情况① for (int j = 1; j &lt;= i / 2; j++) &#123; dp[i] = min(dp[i], dp[j] + i / j * 2 + 3 + dp[i%j]); //情况② dp[i] = min(dp[i], dp[j] + i / j * 2 + 5); //情况③ &#125; &#125; cout &lt;&lt; dp[N] &lt;&lt; endl; &#125; return 0;&#125; 第四题 开心消消乐 (40分)输入一个m,n m表示行数， n表示列数， 输入一串数字，从左到右，从上到下填充，随后还有一串数字，表示缓冲队列Q消除规则;同一行或者同一列有三个相同的数字则消除输入：6 4 123657133245111998578392 123456输出126657 输入 置零 下降 填充 置零 填充 123657 023657 000657 123657 120657 126657 133245 033245 023245 423245 420245 420245 111998 000998 033998 533998 530998 530998 578392 578392 578392 578392 578392 578392 题解（自己写的代码写完没来得及调试时间就到了，所以此处引用一个类似题目的代码，日后有时间再来修改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//// main.cpp// huawei//// Created by SteveWong on 11/10/2016.// Copyright © 2016 SteveWong. All rights reserved.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;ctime&gt;//#include &lt;cstdlib&gt;using namespace std;const int LEN = 8;void pmap(int map[][LEN])&#123; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; cout &lt;&lt; map[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;// 检查以(i,j)为中心的点, 看是否可以消除bool check(int map[][LEN], int i, int j)// 保证i、j不越界,&#123; if ( (i - 1 &gt;= 0 &amp;&amp; i + 1 &lt; LEN &amp;&amp; map[i - 1][j] == map[i][j] &amp;&amp; map[i][j] == map[i + 1][j]) || (j - 1 &gt;= 0 &amp;&amp; j + 1 &lt; LEN &amp;&amp; map[i][j - 1] == map[i][j] &amp;&amp; map[i][j] == map[i][j + 1]) || (i - 2 &gt;= 0 &amp;&amp; map[i - 2][j] == map[i - 1][j] &amp;&amp; map[i - 1][j] == map[i][j]) || (j - 2 &gt;= 0 &amp;&amp; map[i][j - 2] == map[i][j - 1] &amp;&amp; map[i][j - 1] == map[i][j]) || (i + 2 &lt; LEN &amp;&amp; map[i + 2][j] == map[i + 1][j] &amp;&amp; map[i + 1][j] == map[i][j]) || (j + 2 &lt; LEN &amp;&amp; map[i][j + 2] == map[i][j + 1] &amp;&amp; map[i][j + 1] == map[i][j]) ) &#123; return true; &#125; return false;&#125;bool swapAndJudge(int m[][LEN], int i, int j)// 保证i、j不越界, 应该对被swap的两个点都做纵向和横向的检查&#123; int map[LEN][LEN]; for (int ii = 0; ii &lt; LEN; ++ii) &#123; for (int jj = 0; jj &lt; LEN; ++jj) &#123; map[ii][jj] = m[ii][jj]; &#125; &#125; // 原来就可以消除 if (check(map, i, j)) &#123; printf(&quot;no need to swap at (%d, %d)\\n&quot;, i, j); return true; &#125; // 只需要向下换和向右换 // 向下换 if (i + 1 &lt; LEN) &#123; swap(map[i + 1][j], map[i][j]); if (check(map, i, j)) &#123; printf(&quot;# swap and sweap! (%d, %d)\\n&quot;, i, j); return true; &#125; if (check(map, i + 1, j)) &#123; printf(&quot;# swap and sweap! (%d, %d)\\n&quot;, i + 1, j); return true; &#125; swap(map[i + 1][j], map[i][j]);// 换回来 &#125; // 向右换 if (j + 1 &lt; LEN) &#123; swap(map[i][j + 1], map[i][j]); if (check(map, i, j)) &#123; printf(&quot;# swap and sweap! (%d, %d)\\n&quot;, i, j); return true; &#125; if (check(map, i, j + 1)) &#123; printf(&quot;# swap and sweap! (%d, %d)\\n&quot;, i, j + 1); return true; &#125; swap(map[i][j + 1], map[i][j]);// 换回来 &#125; return false;&#125;void findMinSwap(int map[][LEN])&#123; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; if (swapAndJudge(map, i, j)) &#123; printf(&quot;gotcha! (%d, %d)\\n&quot;, i, j); &#125; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; srand(unsigned(time(0))); int p[LEN][LEN]; for (int i = 0; i &lt; LEN; ++i) &#123; for (int j = 0; j &lt; LEN; ++j) &#123; p[i][j] = rand() % 10; &#125; &#125; cout &lt;&lt; &quot;xiaoxiaole!\\n&quot;; findMinSwap(p); pmap(p); system(&quot;pause&quot;); return 0;&#125; 后记每次考试都是意犹未尽的感觉，还是有很多完善的地方，很多知识点还得多练习。刷题目前可能将近100道，还是得多刷多码。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"拼多多ios客户端笔试","slug":"exam_pdd","date":"2020-08-02T06:00:00.000Z","updated":"2020-08-04T04:39:42.173Z","comments":true,"path":"2020/ckfdz0o540016ai9k3nxzd0uk/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o540016ai9k3nxzd0uk/","excerpt":"","text":"前言这半年一直再做客户端，但是我们的客户端与实际大厂的客户端，又不尽相同。客户端可以分为ios，Android，windows，mac等，ios主要要求Object-C和Swift, Android主要用Java。Windows和Mac可能要求C++。所以就项目基础来说去做Windows下的客户端可能会有一定优势，看了这多岗位，感觉字节的C++ 客户端研发工程师-抖音/火山直播这个是比较接近的。当然还有游戏客户端，游戏客户端往往还要求你熟悉一门脚本语言，因为纯c++的游戏，马上就会被外挂搞得毫无游戏体验，脚本的加密，让外挂的制作难度提升了一个档次。除此之外，还会要求你有主流游戏引擎的操作经验，图形学接口的熟悉，shader的编写能力等等。相比华为的宽泛要求，这些细致的要求让你忘而却步。现在的主流市场已经往移动端发展，那么在主机上制作客户端的岗位又会渐渐缩水。ios客户端和Android客户端相比较而言更加吃香。 如果继续学习C++，去华为阿里这样的地方做底层开发，操作系统内核，数据库可能是比较好的处理。还有就是做游戏，计算机图形学的相关内容。现在准备java去达到一个面试水平，应该是比较难的。所以现阶段，应该还是好好看看操作系统，数据库相关内容的书籍。图形学和游戏引擎的熟悉可能稍微滞后一些，感觉相对而言会比较没那么快上手。简单做个fps游戏，作为简历上的闪光点，当然也是一个值得考虑的事情。 前一段时间已经投了五六家大厂，接下来的半个月应该稍微静下心来，继续准备，先不投一段时间，因为接踵而至的笔试和面试，会让你喘不过气，每天都处于这个没面好，那个没考好的焦虑当中。 第一题 单项选择 (5道)主要考察OBJECT-C的内容 一个比较关键的字眼就是KVC。 KVC（Key-value coding）键值编码，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。 作者：jackyshan链接：https://www.jianshu.com/p/b9f020a8b4c9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第二题 多项选择（5道）主要印象就是涉及到资源池资源释放什么的知识点，因为对ios一窍不通，所以就连题目也记不住了。 第三题 飞行棋 (25分)输入第一行 输入K，N，K表示距离终端的距离，N表示丢骰子的次数第二行 输入N个数 表示每次丢骰子的点数大小。输出 如果在N步之前到达终点则打印”paradox”否则输入 距离终点的距离，和回退的次数。两个数自间用空格隔开。回退就是飞行棋一样到终点多了的就往回走。 例：输入：10 36 6 6输出：4 2 坑点就是这个N步之前阻止了很多人AC。 题解（AC 100%）123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int k, n; while (cin &gt;&gt; k &gt;&gt; n) &#123; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; int tmp; cin &gt;&gt; tmp; k -= tmp; // 回退 if (k &lt; 0) &#123; k = -k; cnt++; &#125; // N步之前到达终点 else if (k == 0 &amp;&amp; i != n - 1) &#123; cout &lt;&lt; &quot;paradox&quot; &lt;&lt; endl; &#125; &#125; cout &lt;&lt; k &lt;&lt; &#x27; &#x27; &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 第四题 相同的骰子 (25分)输入N N表示输入骰子的个数随后输入N个骰子，每个数字顺序上下左右前后。输出第一行输出有多少个不同的骰子第二行输出每种骰子的个数 例：输入：2123456625314 输出：21 1 思路这道题没找到题解，讲讲思路吧，我定义了三个函数对骰子做变换，三个自由度，每个自由度可以动0-3下，然后做比较。这个算法的时间复杂度分析。变换与比较的时间是常数C,每加入一个骰子都与前面N-1个骰子比较。估算时间复杂度为o(N^2);这算是暴力解法，AC应该是AC不了。 第五题 吃饭问题 (25分)输入：第一行输入M,N,T M表示午餐的套餐数，N表示晚餐的套餐数,T表示最要要达到的美味值随后M行输入Xi, Yi, Xi表示热量值， Yi表示美味值随后N行输入Xj, Yj, Xj表示热量值， Yj表示美味值输出：求在满足美味值的前提下，最少摄入的热量。可以选择不吃饭或者只吃一顿饭，一顿饭只能吃一种套餐。如果达不到美味值，输出-1 例子：输入3 1 84 33 58 92 5输出6 题解（自己写了个N^2的算法只能AC40%，这个是别人AC94%的代码）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667作者：澹台棋晴链接：https://www.nowcoder.com/discuss/465070?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=-2&amp;source_id=search_all来源：牛客网#include &lt;bits/stdc++.h&gt;#include &quot;iostream&quot;#include &quot;vector&quot;#include &quot;algorithm&quot;using namespace std; int N,M,T;bool cmp(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b)&#123; return a.first&gt;b.first;&#125;int main() &#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;T; int x,y; int maxYlunch=0,maxYdinner=0; vector&lt;pair&lt;int,int&gt;&gt;lunch; vector&lt;pair&lt;int,int&gt;&gt;dinner; while(N--)&#123; cin&gt;&gt;x&gt;&gt;y; lunch.push_back(make_pair(y,x)); maxYlunch = max(maxYlunch,y); &#125; while(M--)&#123; cin&gt;&gt;x&gt;&gt;y; dinner.push_back(make_pair(y,x)); maxYdinner = max(maxYdinner,y); //cout&lt;&lt;&quot; sdfsdfsd&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;maxYdinner&lt;&lt;&quot; &quot;&lt;&lt;maxYlunch&lt;&lt;&quot; &quot;&lt;&lt;T; if((maxYlunch+maxYdinner)&lt;T)&#123; cout&lt;&lt;-1&lt;&lt;&quot; &quot;; return 0; &#125; sort(lunch.begin(),lunch.end()); sort(dinner.begin(),dinner.end(),cmp);//从小到大排序否则超时了 //cout&lt;&lt;&quot; sdfsdfsd1&quot;&lt;&lt;endl; int fat=100000; for(int i=0;i&lt;lunch.size();i++)&#123; //cout&lt;&lt;lunch.size()&lt;&lt;&quot; &quot;; //cout&lt;&lt;&quot; sdfsdfsd2&quot;&lt;&lt;endl; if(lunch[i].first&gt;=T)&#123; fat = min(fat,lunch[i].second); continue; &#125; for(int j=0;j&lt;dinner.size();j++)&#123; if((lunch[i].first + dinner[j].first)&gt;=T)&#123; fat = min(fat,lunch[i].second+dinner[j].second); &#125; else&#123; break;//排序为了节省时间的，后边的都小，不满足条件，直接跳出就可以 &#125; &#125; &#125; for(int i=0;i&lt;dinner.size();i++) &#123; if (dinner[i].first &gt;= T) &#123; fat = min(fat, dinner[i].second); &#125; &#125; cout&lt;&lt;fat&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"7.31 阿里笔试","slug":"exam_ALBB","date":"2020-07-31T06:00:00.000Z","updated":"2020-07-31T16:04:31.871Z","comments":true,"path":"2020/ckfdz0o4z000sai9keqsd2uw7/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4z000sai9keqsd2uw7/","excerpt":"","text":"前言一小时两道题， 吃完晚饭就整装待发准备做了，还是有点紧张的。想要做出一道就勉强混过去。 第一题 带牛去吃草多少种组合方式小明带着n头牛 有m种颜色，每头牛都是互异的。小明带任意头牛出去吃草。请问有多少种组合？种类太多 取模 1e9+71&lt;= n &lt;= 1e9, 1&lt;= m &lt;= 1e9 例：输入：3， 2 输出27 举例带0头 1带1头 3 2带2头 3 2 2带3头 1 2 2 21 + 6 + 12 + 8 = 27 自己猜测的题解我当时看到这个就想到杨辉三角,当时没过，我当时忘了取模1e9但是不知道自己思路是否正确，因为我当时没思路就跳到第二题了。 1234567891011#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123; long long n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; cout &lt;&lt; (long long) pow(m + 1, n) % 1e9 &lt;&lt; endl; &#125;&#125; 第二题 迷宫中的最短路径第一行输入，n,m,p 在（1，500）之间随后输入n行m长度的字符串 C代表陆地， S代表海洋随后p行按照bx, by, ex, eybx,by代表起点 ex,ey代表终点 输出起点到终点所需要最少体力 移动规则：只能上下左右四个方向，陆地到陆地消耗3体力，海洋到海洋消耗2体力，海洋到陆地或陆地到海洋消耗5体力， 输入：4 4 2CCCSSSSSCSCSSSCC1 1 4 33 1 1 3 输出：1314 事后多花了半小时调通的题解没机会扔进去测试一下对不对了。 感觉自己蛮代码的速度好慢呀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;queue&gt;using namespace std;int xr[4] = &#123;1, -1, 0, 0&#125;;int yr[4] = &#123;0, 0, 1, -1&#125;;int n, m ,p;bool inMat(int x, int y) &#123; return x&gt;=0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;vector&lt;vector&lt;int&gt;&gt; bfs(int bx, int by, vector&lt;string&gt; &amp;mat) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(m , 0x3f3f3f)); q.push(make_pair(bx, by)); res[bx][by] = 0; while(!q.empty()) &#123; pair&lt;int, int&gt; tmp = q.front(); q.pop(); int tx = tmp.first, ty = tmp.second; for(int i = 0; i &lt; 4 ;i ++) &#123; //判断是否在界内 if(inMat(tx+xr[i], ty + yr[i])) &#123; if(mat[tx][ty] == mat[tx + xr[i]][ty+yr[i]]) &#123; if(mat[tx][ty] == &#x27;C&#x27;) &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 3) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 3; &#125; else &#123; //无更新， 跳过 continue; &#125; &#125; if(mat[tx][ty] == &#x27;S&#x27;) &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 2) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 2; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; if(res[tx + xr[i]][ty+yr[i]] &gt; res[tx][ty] + 5) &#123; res[tx + xr[i]][ty+yr[i]] = res[tx][ty] + 5; &#125; else &#123; continue; &#125; &#125; //有更新，进队 q.push(make_pair(tx+xr[i], ty + yr[i])); &#125; &#125; &#125; return res;&#125;int main(int argc, const char * argv[]) &#123; //cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; n = 4; m = 4; p = 2; //vector&lt;string&gt; mat(n, &quot;&quot;); vector&lt;string&gt; mat; mat.push_back(&quot;CCCS&quot;); mat.push_back(&quot;SSSS&quot;); mat.push_back(&quot;CSCS&quot;); mat.push_back(&quot;SSCC&quot;);// for(int i = 0; i &lt; n; i++) &#123;// cin &gt;&gt; mat[i];// &#125;// vector&lt;vector&lt;int&gt;&gt; be(p,vector&lt;int&gt;(4, 0) );// for(int i = 0; i &lt; p; i++) &#123;// for(int j = 0 ; j &lt; 4; j++) &#123;// cin &gt;&gt; be[i][j];// &#125;// &#125; vector&lt;vector&lt;int&gt;&gt; be = &#123;&#123;1, 1, 4, 3&#125;, &#123;3, 1, 1, 3&#125;&#125;; for(int i = 0 ; i &lt; p; i++) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , 0x3f3f3f)); // 题目中列为x， 行为y dp = bfs(be[i][1] - 1, be[i][0] - 1, mat); int ex = be[i][3], ey = be[i][2]; cout &lt;&lt; dp[ex - 1][ey - 1]&lt;&lt; endl; &#125; return 0;&#125; 后记这次笔试我两道题都是0， 不知道会不会连面试的机会都没有， 每道题的题解也不知道对不对，有没有参加了并AC的大佬来指点一下迷津。刷题还得刷呀，code速度太慢了，思路没那么清晰，都是码一点想一点。我好菜呀，阿里好难。 抄袭一下AC的答案第一题123456789101112131415161718192021222324252627作者：zyx_xiao链接：https://www.nowcoder.com/discuss/464106?type=0&amp;order=0&amp;pos=7&amp;page=1&amp;channel=666&amp;source_id=discuss_tag来源：牛客网#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll ;ll n, m;ll powmod(ll x,ll n ,ll mod)&#123; ll res=1; while(n&gt;0) &#123; if(n&amp;1LL) res=res*x%mod ; x=x*x%mod; n&gt;&gt;=1; &#125; return res ;&#125;int main()&#123; ll mod = 1000000007; scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); m++; printf(&quot;%lld\\n&quot;, powmod(m, n, mod)); return 0;&#125; 第二题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354作者：zyx_xiao链接：https://www.nowcoder.com/discuss/464106?type=0&amp;order=0&amp;pos=7&amp;page=1&amp;channel=666&amp;source_id=discuss_tag来源：牛客网#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, q;char mp[505][505];int vis[505][505];int dx[4] = &#123;0,0,1,-1&#125;;int dy[4] = &#123;1,-1,0,0&#125;;int bx,by,ex,ey;struct node&#123; int x,y; node(int xx,int yy):x(xx),y(yy)&#123;&#125;&#125;;int main()&#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 0 ; i &lt; n ; i++) scanf(&quot;%s&quot;, mp[i]); while(q--)&#123; for(int i = 0 ; i &lt; n ; i++) for(int j = 0 ; j &lt; m ; j++) vis[i][j] = 10000000; scanf(&quot;%d %d %d %d&quot;, &amp;bx, &amp;by, &amp;ex, &amp;ey); bx--;by--;ex--;ey--; vis[bx][by] = 0; queue&lt;node&gt; que; que.push(node(bx, by)); while(!que.empty())&#123; node t = que.front(); que.pop(); for(int i = 0 ; i &lt; 4 ; i++)&#123; int x = t.x + dx[i]; int y = t.y + dy[i]; if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m) continue; int w = 5; if(mp[x][y]==mp[t.x][t.y])&#123; if(mp[x][y]==&#x27;C&#x27;) w = 3; else w = 2; &#125; if(vis[x][y] &lt;= vis[t.x][t.y]+w) continue; vis[x][y] = vis[t.x][t.y] + w; que.push(node(x,y)); &#125; &#125; printf(&quot;%d\\n&quot;, vis[ex][ey]); &#125; return 0;&#125;","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"华为提前批综合面试","slug":"interview_HW_3","date":"2020-07-30T06:00:00.000Z","updated":"2020-07-30T15:19:07.032Z","comments":true,"path":"2020/ckfdz0o5h001vai9k61xe9ugc/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5h001vai9k61xe9ugc/","excerpt":"","text":"前言开始很紧张，面试前巨害怕。会不会和自己昨晚在网上搜索的内容一样有相似的经历。然后，又不得不请个假。面试前面试官不能录屏。然后又反复进入，留我一个人在视频里。这次面试没有像前两次一样一上来就手撕代码。（我前两次都没能撕出来）。主要的面试内容就是看着你的简历向你提问。 面试要点 询问了本科和研究生的绩点 询问了本科和研究生的主要课程 询问课程在实际生活是否有应用，在哪里 询问了软件开发的完整流程 询问了个人的优缺点，分别在哪里体现 询问了为什么选择进入软件开发 周末喜欢做什么 询问了个人对地域选择的意愿 询问了学长学姐的主要去向 询问了个人对薪资的期望 反问面试官 你能给我介绍一下杭州的主要业务？华为的四大BG，软件研究院里面主要做研究的。杭州定位为计算研究所。华为开源的各种底层服务，open欧拉 open罗庚等等。 如果我进入计算产品线，需要具备哪些计算栈？主要强力推荐了《计算机体系结构》。 后记隔天，查看官网的招聘进度，已经显示通过，并且询问了在职学长，说明已经进入池子了。等待被打捞，收获第一个offer。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为软件开发工程师提前批二面","slug":"interview_HW2","date":"2020-07-28T04:33:28.944Z","updated":"2020-07-28T04:33:28.944Z","comments":true,"path":"2020/ckfdz0o5d001nai9k5vlabsmj/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5d001nai9k5vlabsmj/","excerpt":"","text":"前言一个电话没接着，打不回去，就好怕改时间还是自己错过了。打校招电话回去咨询。还请教了一面的面试官。不过最后还是完美收尾了 手写代码进来先考察代码能力，这次题目是leetcode316原题，因为没刷到过，而且本身对回溯的算法还不是很熟，所以没能在规定时间内，完成这道题目。后面参考答案后写出的解题：123456789101112131415class Solution &#123;public: string removeDuplicateLetters(string s) &#123; string str; for(size_t i = 0; i &lt; s.size(); i++) &#123; if(str.find(s[i]) != string::npos) continue; while(!str.empty() &amp;&amp; str.back() &gt; s[i] &amp;&amp; s.find(str.back(), i)!=string::npos) str.pop_back(); str.push_back(s[i]); &#125; return str; &#125;&#125;; 贪心加栈，同时，当根据条件去掉一个栈顶元素时，新的栈顶元素可能也大于当前元素，所以应该继续判断新的栈顶元素和当前元素的关系，用一个while循环，直到出现一个不满足循环条件的栈顶元素（要么小于当前元素，要么大于当前元素但后续又无与之相同的元素来替代）。 剩下进去问答环节1.考察了设计模式2.考察了面向对象的三个特点3.考察了stl和红黑树4.考察了C++虚函数5.询问了项目相关6.考察了模版类7.考察了软件工程相关的整个流程8.考察了类的六大特性9.new和molloc的区别10.构造函数和析构函数的调用过程11.介绍一下继承的种类 我询问面试官软件工程的知识在实际开发过程中真的会用到么会用到很多，对于整个过程管理会很严格，文档和单元测试，集成测试等环节。 后记感觉整个面试还是很不错，但是不知道会不会有三面，好想拿到offer！","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为软件开发工程师提前批一面","slug":"interview_HW_1","date":"2020-07-26T08:04:28.466Z","updated":"2020-07-26T08:04:28.466Z","comments":true,"path":"2020/ckfdz0o5c001jai9k0mlpaxr0/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5c001jai9k0mlpaxr0/","excerpt":"","text":"前言紧张激动，不知所措。面对一个大黑幕，但是看着自己就好像没有看着字节面试官那时候紧张了。 手写代码进来先考察代码能力，这次题目是leetcode40原题，因为没刷到过，而且本身对回溯的算法还不是很熟，所以没能在规定时间内，完成这道题目。后面参考答案后写出的解题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// main.cpp// test_HW//// Created by 张嘉喜 on 2020/7/24.// Copyright © 2020 张嘉喜. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; candidates; vector&lt;int&gt; path;public: void DFS(int start, int target) &#123; if(target == 0) &#123; ans.push_back(path); return; &#125; for(int i = start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0 ; i++) &#123; //剪枝去重 //这里i &gt; start 放在前面不然有些编译器会提示数组越界了 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); DFS(i + 1, target - candidates[i]); // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; // 排序后方便剪枝 sort(candidates.begin(), candidates.end()); this-&gt;candidates = candidates; DFS(0, target); return ans; &#125;&#125;;int main(int argc, const char * argv[]) &#123; vector&lt;int&gt; candidates ; candidates.push_back(10); candidates.push_back(1); candidates.push_back(2); candidates.push_back(7); candidates.push_back(6); candidates.push_back(1); candidates.push_back(5); Solution s = Solution(); vector&lt;vector&lt;int&gt;&gt; ans = s.combinationSum2(candidates, 8); for(int i = 0 ; i &lt; ans.size(); i++) &#123; for(int j = 0 ; j &lt; ans[i].size(); j++ ) &#123; cout &lt;&lt; ans[i][j] &lt;&lt; endl; &#125; &#125; return 0;&#125; 对于回溯和剪枝的题目还是作太少了。应该要加强练习。 剩下进去问答环节1.查看了我leetcode的刷题情况，询问我主要擅长什么类型的题目，能否独立完成困难题目。2.询问了是否知道回溯。3.考察了DFS和BFS，原理和实现，应用场景4.考察了C++虚函数5.能讲解一下类吗6.询问了项目相关7.询问是否对数据库底层原理了解8.学习能力怎么样 我询问面试官准备秋招还有哪些方面1.继续刷题，笔试500分会重点关注。要了解更多的算法思想，并查集，回溯，递归，递推，归并，贪心，动态规划，模拟，枚举2.熟悉操作系统，因为杭研所主要还是做底层开发的，所以对整个CPU执行程序的过程，汇编等需要用到3.如果有兴趣来做数据库的话，也要需要了解数据库相关的底层原理 后记和面试官整个沟通过程，感觉整个状态很好，所以也如愿以偿收到二面通知，明天就要二面了。加油～","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"华为笔试总结","slug":"exam_HW","date":"2020-07-23T06:00:00.000Z","updated":"2020-07-25T09:19:20.252Z","comments":true,"path":"2020/ckfdz0o530014ai9k25bz6qkh/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o530014ai9k25bz6qkh/","excerpt":"","text":"前言中午预约的机考时间，记错成了第二天晚上才开始。结果，晚上7点多和朋友过生日的时候，收到了短信，提醒考试已经开始快半小时了。赶紧跑了回来。内心一百只草泥马飞过。总体而言就算给我更多的时间不一定思路就清晰了。 1.求余数给定两个数，将两个数的各位求和在求余数。例如：输入：123 11 输出：0 （1+2+3）%（1+1） = 6%2 = 0； 题解12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int solution(long long m, long long n) &#123; int am = 0, an = 0; while(m) &#123; am += m % 10; m /= 10; &#125; while(n) &#123; an += n % 10; n /= 10; &#125; return am % an;&#125;int main() &#123; // 怕数字范围溢出， 得回去记一下每个数据类型的表示范围。 long long m, n; // 牛客对于简单的测试需要循环输入。 while(cin &gt;&gt; m &gt;&gt; n) cout &lt;&lt; solution(m, n) &lt;&lt; endl; return 0;&#125; 这道题画了没几分钟，主要用来适应环境的。 2. 买最少的东西有五件商品，价格分别是1，3，7，11，13.给定的钱，和各商品数量，然后购买最少商品的数量， 务必将钱花完。例如：输入：1 2 3 4 530输出：4 2 13 + 1 3 + 1 * 1 = 30；2 + 1 + 1 = 4； 题解1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using pii = pair&lt;int, int&gt;;#define X first#define Y secondvector&lt;int&gt; price = &#123;1,3,7,11,13&#125;;int main() &#123; int V; vector&lt;pii&gt; packs; for(int i = 0 ; i &lt; 5; i++)&#123; int cnt, k = 1; cin &gt;&gt; cnt; while(cnt &gt; k)&#123; //混合背包转01背包 packs.push_back(&#123;k, k * price[i]&#125;); cnt -= k; k *= 2; &#125; if(cnt) packs.push_back(&#123;cnt, cnt * price[i]&#125;); &#125; cin &gt;&gt; V; vector&lt;int&gt; dp(V + 1, 0x3f3f3f);//dp[i],花费i，数量最少 dp[0] = 0; for(auto&amp; pack: packs) &#123; for(int j = V; j &gt;= pack.Y; --j) &#123; dp[j] = min(dp[j], dp[j - pack.Y] + pack.X); &#125; &#125; cout &lt;&lt; dp[V]; return 0;&#125; 3. 给定距离的不同走法给定距离，并给出各种步长，nums[0]…num[n -1],请问有多少种走法（不考虑走路的顺序）先走短的再走长的，步长互异。 例如：输入：41 2 输出：31+1+1+1 = 41+1+2 = 4；2+2 = 4题解12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(int n, vector&lt;int&gt; &amp; num) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for(int i = 0; i &lt; num.size(); i++)&#123; for(int j = num[i]; j &lt;= n; j++) &#123; dp[j] += dp[j - num[i]]; &#125; &#125; return dp[n];&#125;int main() &#123; int n; vector&lt;int&gt; num; cin &gt;&gt; n; int temp; // 这里不能想牛客那样推出， 我就定义输入零结束输入 while(cin &gt;&gt; temp) &#123; if(!temp) break; num.push_back(temp); &#125; sort(num.begin(), num.end()); cout &lt;&lt; solution(n, num)&lt;&lt;endl; return 0;&#125; 总结后面两个解答都是参考了牛客博主xinxin1000的答案，还附赠了背包问题学习大礼包https://anivian.github.io/pack-master/V2.pdf超级感谢这位来自清华的小姐姐。希望明天面试顺利～～～～","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"进程间通信","slug":"Interprocess_communication","date":"2020-07-14T06:00:00.000Z","updated":"2020-07-25T09:17:59.758Z","comments":true,"path":"2020/ckfdz0o4f0001ai9kbvdc0axv/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4f0001ai9kbvdc0axv/","excerpt":"","text":"进程协作的目的 信息共享： 由于多用户可能对同样的信息感兴趣（例如共享文件），所以应提供环境以允许并发访问这些信息。 计算加速： 如果希望一个特定快速运行，那么应将系统功能划分成子任务，而每个子任务可以与其他子任务一起并行执行。注意，如果要实现这样的加速，那么计算机需要有多个处理核。 模块化： 可以需要按模块化方式构造系统，如第2章所讨论的，可将系统功能划分成独立的进程和线程。 方便： 即使单个用户也可以同时执行许多任务。例如，用户可以并行的编辑、收听音乐、编译。 协作进程需要进程间通信（IPC)进程间通信的两种基本模型：共享内存和消息传递共享内存系统采用共享内存的进程间通信，需要通信进程建立共享内存区域。通常，一片共享内存区域驻留在创建共享内存段的进程空间内。其他希望使用这个共享内存段进行通信段进行通信的进程应将其附加到自己的地址空间。 生产者进程生成信息，以供消费者进程消费。为了允许生存者进程和消费者进程并发执行，应有一个可用的缓冲区，以被生存者填充和被消费者清空。这个缓冲区驻留在生产者进程和消费者进程的共享内存区域内。当消费者使用一项时，生产者可生产另一项。生产者和消费者必须同步，这样消费者不会试图消费一个尚未生产出来的项。 缓冲区域类型可分为两种。无界缓冲区没有限制缓冲区的大小。消费者可能不得不等待新的项，但生产者总是可以产生新项。有界缓冲区假设固定大小的缓冲区。对于这种情况，如果缓冲区空，那么消费者必须等待；并且如果缓冲区满，那么生产者必须等待。 采用共享内存的生产者进程如下：123456789while(true) &#123; &#x2F;* produce an item in next_produced *&#x2F; while(((in + 1) % BUFFER_SIZE) &#x3D;&#x3D; out) ; &#x2F;* do nothing *&#x2F; buffer[in] &#x3D; next_produced; in &#x3D; (in + 1) % BUFFER_SIZE;&#125; 采用共享内存的消费者进程如下：12345678while(true) &#123; while(in &#x3D;&#x3D; out) ;&#x2F;* do nothing *&#x2F; next_consumed &#x3D; buffer[out]; out &#x3D; (out + 1) % BUFFER_SIZE; &#x2F;* consume the item in next_consumed *&#x2F;&#125; 消息传递系统对于分布式环境（通信进程可能位于通过网络连接的不同计算机），消息传递特别有用。消息传递工具提供至少两种操作： send(message) recevie(message) 进程发送消息可以是定长的或变长的。如果只能发生定长消息，那么系统级实现就简单。不过，这一限制使得编程任务更加困难。相反，变长消息要求更复杂的系统级实现，但是编程任务就变得更简单。在整个操作系统设计中，这种折中很常见。 如果进程P和Q需要通信，那么它们必须相互发送消息和接受消息：它们之间要有通信链路。该链路的实现有多种方法。这里不关心链路的物理实现，而只关心链路的逻辑实现。这里有几个方法，用于实现链路和操作send()/receive(): 直接或间接的通信 同步或异步的通信 自动或显式的缓冲 1. 命名需要通信的进程应有一个方法，以便相互引用。它们可以直接或间接的通信。对于直接通信，需要通信的每个进程必须指明指定通信的接收者或发送者。采用这种方案，原语send()和receive()定义如下： send(P, message): 向进程P发送message。 receive(Q, message)： 从进程Q接收message。 这种方案的通信链路具有以下属性： 在需要通信的每对进程之间，自动建立链路。进程仅需知道对方身份就可交流。 每个链路只与两个进程相关。 每个进程只有一个链路。 这种方案展示了寻址的对称性，即发送和接收进程必须指定对方，以便通信。这种方案的一个变形采用寻址的非对称性，即只要发送者指定接收者，而接受者不需要指定发送者。采用这种方案，原语send()和receive()的定义如下： send(P, message): 向进程P发送message。 receive(id, message): 从任何进程，接收message，这里变量id被设置成与其通信进程的名称。 这两个方案（对称和非对称的寻址）的缺点是：生成进程定义的有限模块化。更改进程的标志符可能需要分析其他进程定义。所有旧的标志符的引用都应找到，以便修改成为新标识符。通常，任何时候的硬编码技术（其中标志符需要明确指定），与下面所诉的采用间接技术相比要差。 在间接通信中，通过邮箱和端口来接收消息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一的标识符。一个进程可以通过不同邮箱与另一个进程通信，但是两个进程只有拥有一个共享邮箱时才能通信。原语send()和receive()定义如下： send(A, message): 向邮箱A发送message。 receive(A, message): 从邮箱A接收messgae。 对于这种方案，链路通信具有如下特点： 只有两个进程共享一个邮箱时，才能建立通信链路。 一个链路可以与两个或更多进程相关联。 两个通信进程之间可有多个不同链路，每个链路对应于一个邮箱。 2. 同步进程间通信可以通过调用原语send()和receive()来进行。实现这些原语有不同的设计方案。消息传递可以是阻塞或非阻塞，也称为同步或异步。 阻塞发送： 发送进程阻塞，直到消息由接收进程或邮箱所接收。 非阻塞发送： 发送进程发送消息，并且恢复操作。 阻塞接收： 接收进程阻塞，直到消息可用。 非阻塞接收： 接收进程收到一个有效消息或者空消息。 不同组合的send()和receive()都有可能。当send()和receive()都是阻塞的，则在发送者和接收者之间就有一个交互。当采用阻塞的send()和receive()时，生产者-消费者问题的解决就简单了。生产者仅需调用阻塞send()并且等待，直到消息被送到接收者或者邮箱。同样，当消费者调用reiceve()时，它会阻塞直到有一个消息可用。 采用消息传递的生产者进程如下：123456message next_producedwhile(true) &#123; &#x2F;* produce an item in next_produced *&#x2F; send(next_produced);&#125; 采用消息传递的消费者进程如下：123456message next_comsumedwhile(true) &#123; receive(next_consumed); &#x2F;* consume the item in next_consumed *&#x2F;&#125; 3. 缓存不管通信时直接的还是间接的，通信进程交换的消息总是驻留在临时队列中。简单地讲，队列实现有三种方法： 零容量：队列的最大长度为0；因此，链路中不能有任何消息处于等待。对于这种情况，发送者应阻塞，直到接收者接收消息。 有限容量： 队列长度为有限的n；因此，最多只能有n个消息驻留其中。如果在发送消失时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发生者可以继续执行而不必等待。然而，链路容量是有限。如果链路已满，那么发送者应阻塞，直到队列空间有有用的为止。 无限容量： 队列长度可以无限，因此，不管多少消息都可以在其中等待。发送者从不阻塞。 零容量情况称为无缓冲的消息系统，其他情况称为自动缓冲的消息系统。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"字节跳动秋招提前批c++客户端一面","slug":"interview_ByteDance","date":"2020-07-06T06:00:00.000Z","updated":"2020-07-25T09:18:16.217Z","comments":true,"path":"2020/ckfdz0o5e001pai9khou43ssb/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5e001pai9khou43ssb/","excerpt":"","text":"内心独白算是第一次正式的视频面试，还是很紧张……( ´▽｀)； 过程总结 简短的自我介绍 询问项目相关 QML和QWeight比较，当初项目为什么选用这个 OpenGL版本 QT的信号与槽， 可以用什么代替 进程间通信方式，线程间通信方式 c++面向对象的三个特性具体解释一下 关于一段代码的虚函数调用后结果 关于虚函数表的问题 反思感觉对于图形学实际学习还存在欠缺，对于操作系统和C++语言深入了解不够细致，只是懂个大概，实际应用能力还有待增长。QT相关的应用也应该更加深入了解。查漏补缺吧。对于一面提及到的知识点回去好好温习巩固一下。只是提前批的第一波，不知道后面的公司有没有音讯，继续学习。期待能有二面吧，目前还是很想去字节上班的。","categories":[{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"动态库与静态库的区别","slug":"libvdll","date":"2020-06-27T06:00:00.000Z","updated":"2020-07-25T09:19:03.467Z","comments":true,"path":"2020/ckfdz0o5l0027ai9kewxe8vel/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5l0027ai9kewxe8vel/","excerpt":"","text":"区别：静态库和动态库最本质的区别就是：该库是否被编译进目标（程序）内部。 静态（函数）库一般拓展名为（.a或者.lib),这类的函数库通常拓展名为libxxx.a或者xxx.lib。这类库在编译的时候会直接整合到目标程序中，所以利用静态函数库编译程的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。 动态函数库动态函数库的拓展名一般为 （.so或.dll)，这类函数库通常名为libxxx.so或xxx.dll。与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序中只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。 总结 从产品化的角度，发布的算法库和功能库尽量使用动态库，这样方便更新和升级，不必重新编译整个可执行文件，只需新版本动态库替换掉旧动态库即可。 从函数库集成的角度，若要将发布的所有子库（不止一个）集成成一个动态库向外提供接口，那么就需要将所有子库编译为静态库，这样所有子库就可以全部编译进目标动态库中，由最终的一个集成库向外提供功能。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"什么是死锁？在什么情况下产生？怎么解决？","slug":"deadlock","date":"2020-06-23T06:00:00.000Z","updated":"2020-09-20T15:07:34.046Z","comments":true,"path":"2020/ckfdz0o4w000lai9k8v0phsgn/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4w000lai9k8v0phsgn/","excerpt":"","text":"在多道程序环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么等待进程有可能再也无法改变状态。这种情况称为死锁（deadlock）。 死锁的必要条件：如果在一个系统中以下四个条件同时成立，那么就能引起死锁： 互斥（ mutual exclusion）：至少一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。 占有并等待（ hold and wait ）：一个进程应占有至少一个资源，并等待另一个资源，该资源为其他进程所占有。 非抢占（ no preemption ）：资源不能被抢占，即资源只能被进程完成任务后自愿释放。 循环等待（ circular wait ）：$有一组等待进程{P{0} , P{1} ,···,P{n}) ,P{0}等待的资源为P{1}占有，P{1}等待的资源为P{2}占有，·······,P{n-1}等待的资源为P{n}占有，P{n}等待的资源被P_{0}占有。$ 四个条件必须同时成立才会出现死锁。循环等待条件意味着占有并等待条件，这样四个条件并不完全独立。 一般来说，处理死锁问题有三种方法： 通过协议来预防和避免死锁，确保系统不进入死锁状态。 可以允许系统进入死锁状态，然后检测它，并加以恢复。 可以忽视这个问题，认为死锁不可能在系统内发生。 第三种解决为大多数操作系统所采用，包括Linux和windows。因此应用程序开发人员需要自己编写程序，以便处理死锁。 死锁预防 死锁避免 死锁检测 死锁恢复。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"虚函数","slug":"virtual","date":"2020-06-20T10:22:26.698Z","updated":"2020-07-25T09:03:11.346Z","comments":true,"path":"2020/ckfdz0o5m002aai9k875w4mkt/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5m002aai9k875w4mkt/","excerpt":"","text":"定义在c++中，基类必须指出派生类重定义哪些函数，定义为virtual的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。（c++ primer） 动态绑定在C++中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）即可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。 保留字virtual的目的是启用动态绑定。成员默认是非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型类型前面加上保留字virtual。除了构造函数外，任何非static成员函数都可以是虚函数。保留字virtual只能在类内部的成员函数声明中出现，不能在类定义体外部出现的函数定义上。 派生类与虚函数尽管不是必须这么做，派生类一般会重定义所继承的虚函数。如果派生类没有重定义某个虚函数，则使用基类中定义的版本。派生类必须对想要重定义的每个继承成员进行声明。派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 tips：一旦函数在基类中声明为虚函数，他就一直为虚函数，派生类无法改变该函数为虚函数这一事实。派生类重定义虚函数时，可以使用virtual保留字，但不是必须这么做。 覆盖虚函数机制在某些情况下，希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，这时可以用作用域操作符：123Item_base *baseP &#x3D; &amp;derived;&#x2F;&#x2F; calls version from the base class regardless of the dynamic type of basePdouble d &#x3D; baseP -&gt; Item_base::net_prise(42);这段代码强制将net_price调用确定为Item_base中定义的版本，该调用将在编译时确定。为什么会希望覆盖虚函数机制？最常见的理由是为了派生类虚函数调用基类中的版本。在这种情况下，基类版本可以完成继承层次中所有类型的公共任务，而每个派生类型只添加自己的特殊工作。 tips：派生类虚函数调用基类版本时，必须显式使用作用域操作符。如果派生类忽略这样做，则函数调用会在运行时确定并且将是一个自身调用，从而导致无穷递归。 虚函数与默认实参像其他任何函数一样，虚函数也可以有默认实参值，该值将在编译时确定。如果一个调用省略了具有默认值的实参，则所用的值由调用该函数类型定义，与对象的动态类型无关。通过基类的引用或指针调用虚函数时，默认实参为在基类虚函数声明中指定的值，如果通过派生类的指针或引用调用虚函数，则默认实参是在派生类版本中声明的值。 在同一虚函数的基类版本和派生类版本中使用不同的默认实参几乎一定会引起麻烦。如果通过基类的引用或指针调用虚函数，但实际执行的是派生类中定义的版本，这时就可能会出现问题。在这种情况下，为虚函数的基类版本定义的默认实参将传给派生类定义的版本，而派生类版本是用不同的默认实参定义的。 c++的多态性引用和指针的静态类型和动态类型可以不同，这是C++用以支持多态性的基石。 通过基类引用或指针调用基类中定义的函数时，我们并不知道执行函数的对象的确切类型，执行函数的对象可能是基类类型的，也可能是派生类型的。 如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定的或指针所指向的对象所属类型定义的版本。 虚析构函数自动调用基类部分的析构函数对基类的设计有重要影响。 删除指向动态分配对象的指针时，需要运行析构函数在释放对象的内存之前清理对象。处理继承层次中的对象时，指针的静态类型可能与删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。 如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际时派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：12345class Item_base &#123;public: &#x2F;&#x2F; no work,but virtual destructor needed &#x2F;&#x2F; if base pointer that points to a derived object is ever deleted virtual ~Item_base() &#123; &#125;如果析构函数为虚函数，那么通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同：1234Item_base *itemP &#x3D; new Item_base; &#x2F;&#x2F; same static and dymatic type delete item; &#x2F;&#x2F; ok:destructor for Item_base calleditemP &#x3D; new Bulk_item; &#x2F;&#x2F; ok:static and dynamic types differdelete itemP; &#x2F;&#x2F; ok:destructor for Bulk_item called像其他虚函数一样，析构函数的性质都将继承。因此，如果层次中根类的析构函数也虚函数，则派生类析构函数也将是虚函数，无论派生类显式定义析构函数还是使用合成析构函数，派生类析构函数都是虚函数。 基类虚构函数式三法则的一个重要例外。三法则指出，如果类需要析构函数，则类几乎也确实需要其他复制控制成员，基类几乎总是需要析构函数，从而可以将析构函数设定为虚函数。如果基类为了将析构函数设为虚函数而具有空析构函数，那么，类具有析构函数并不表示需要赋值操作符或复制构造函数。 tips：即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。 构造函数和复制操作符不是虚函数在复制控制成员中， 只有析构函数应定义为虚函数，构造函数不能定义为虚函数。构造函数是对对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。 虽然可以在基类中将对象成员函数 operator=定义为虚函数，但这样做并不影响派生类中使用的复制操作符。每个类有自己的赋值操作符，派生类中的赋值操作符有一个与类本身类型相同的形参，该类型必须不同于继承层次中任何其他类的赋值操作符的形参类型。 将赋值操作符设为虚函数可能会令人混淆，因为虚函数必须在基类和派生类中具有相同的形参。基类赋值操作符有一个形参是自身类类型的引用，如果该操作符为虚函数，则每个类型都将得到一个虚函数成员，该成员定义了参数为一个基类对象的operator=。但是，对派生类而言，这个操作符与赋值操作符是不同的。 tips：将类的赋值操作符定义为虚函数很可能令人混淆，而且没什么用处。 构造函数和析构函数中的虚函数构造派生类对象时首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。 撤销派生类对象时，首先撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。 在这两种情况下，运行构造函数或析构函数的时候，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象作为基类类型对象对待。 构造或析构期间的对象类型对虚函数的绑定有影响。 tips：如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。 无论由构造函数（或析构函数）直接调用虚函数，或者从构造函数（或虚构函数）所调用的函数间接调用虚函数，都应用这种绑定。 要理解这种行为，考虑如果从基类构造函数（或析构函数）调用虚函数的派生类版本会怎样。虚函数的派生类版本很可能会访问派生类对象的成员，毕竟，如果派生类版本不需要使用派生类对象的成员，派生类多半能够使用基类中的定义。但是，对象的派生部分的成员不会在基类构造函数运行期间初始化，实际上，如果允许这样的访问，程序很可能会崩溃。","categories":[{"name":"c++","slug":"c","permalink":"https://shen-yu.gitee.io/categories/c/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"new与malloc的区别","slug":"new_and_malloc","date":"2020-06-18T16:15:16.710Z","updated":"2020-06-18T16:16:47.994Z","comments":true,"path":"2020/ckfdz0o5j0023ai9k757ieo2f/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5j0023ai9k757ieo2f/","excerpt":"","text":"1. molloc与free是C++/c语言的标准函数， new/delete是c++的运算符。2.他们都可以用于申请动态内存和释放内存。new/delete比molloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。既然new/delete的功能完全覆盖了malloc和free， 为什么c++中不把malloc/free淘汰出局呢？因为c++程序经常要调用c语言，而c语言只能用malloc/free管理动态内存。3. new返回指定类型的指针，并且可以自动计算出所需要的大小。malloc必须用户指定大小，并且默认返回类型为void*， 必须强制转换为实际类型的指针。","categories":[],"tags":[]},{"title":"进程和线程","slug":"process","date":"2020-06-17T06:00:00.000Z","updated":"2020-07-25T09:19:45.091Z","comments":true,"path":"2020/ckfdz0o5n002fai9khf47bwgr/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5n002fai9khf47bwgr/","excerpt":"","text":"什么是进程 进程是正在运行的一个应用程序，程序一旦运行就是进程。 进程是系统进行资源分配的最小单位，每个进程拥有独立的地址空间。 一个进程无法直接去访问另外一个进程的变量和数据结构，需要进行进程间通信，包括管程，消息队列。 线程是进程的一个实体，是资源调度的基本单位。 进程与线程的区别 同一进程的线程共享进程的地址空间，而进程之间则是独立的地址空间 同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃后，整个进程崩溃 进程切换，消耗资源大，线程切换时间少于进程 二者均可以并发执行","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"java的基本程序设计结构","slug":"javav1ch03","date":"2020-03-18T06:00:00.000Z","updated":"2020-07-25T09:18:33.115Z","comments":true,"path":"2020/ckfdz0o5g001tai9k55u77ajh/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5g001tai9k55u77ajh/","excerpt":"","text":"最简单的Java程序 java区分大小写 java应用程序的全部内容必须放置在类中 每个句子由分号结尾，回车不是句子的结尾 注释 单行注释// 多行注释/ / 自动生成文档/* / 基本数据类型整形 int 4字节 short 2字节 long 8字节 byte 1字节 浮点型 float 4字节 double 8字节 char类型 常用字符采用单字节编码，，而另一些字符而需要两个或者更多个字节。在Java中采用UTF-16所以占用2字节 boolean（布尔）类型 1位 只有0和1 1字节 1字节是计算机处理最小单位 4字节 java虚拟机规范里规定 变量 命名允许字符，数字和字母。字母包括’A’ ~ ‘Z’、 ‘a’ ~ ‘z’、’_’、’$’或者某种语言中表示字母的任何Unicode字符。数字包括’0’ ~ ‘9’和某种语言中表示数字的任何Unicode字符。 利用关键字final指示常量 声明一个变量后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化对变量 运算符 各运算符的优先级 各数据类型之间的强制类型转换 字符串 字符串的不可变属性 字符串类的一些常用接口 输入与输出 读取输入 格式化输出 文件的输入与输出 流程控制 if else while do while for break 提供了带标签选项 switch continue 提供了带标签选项 大数值 满足更高精度要求的计算 运算需要使用类内方法 数组 for each 数据变量是一种引用 多维数组 不规则数组 XMind: ZEN - Trial Version","categories":[{"name":"java","slug":"java","permalink":"https://shen-yu.gitee.io/categories/java/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"数据链路层","slug":"Data-Link-Layer","date":"2020-03-08T12:28:52.720Z","updated":"2020-07-25T08:55:18.010Z","comments":true,"path":"2020/ckfdz0o4i0003ai9k2t28dkgc/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o4i0003ai9k2t28dkgc/","excerpt":"","text":"使用点对点信道的数据链路层点对点信道的数据链路层在进行通信时的主要步骤如下 1.结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧 2.结点A把封装好的帧发生发生给结点B的数据链路层 3.若结点B的数据链路层收到的帧无差错，则从收到的帧中提取 出IP数据报交给上面的网络层；否则丢弃这个帧 三个基本问题 封装成帧 在一段数据的前后分布添加首部和尾部，这样就构成了一个帧 MTU(Maximum Transfer Unit)最大传送单元是指帧的数据部分长度上限,默认值1500字节 透明传输 “透明”表示某一个实际存在的事物看起来却好像不存在。这些数据就“看不见”数据链路层有什么防碍数据传输的东西。 为解决透明传输问题，发送端的数据链路层在出现控制字符“SOH”和“EOT”之前加入转义字符“ESC”，在接收端的数据链路层把数据运往网络层之前删除这些之前插入的转义字符。这种方法叫字节填充或字符填充。 差错检测 误码率 在一段时间内，传输错误的比特占所传输比特总数的比率 循环冗余检测CRC(Cyclic Redundancy Check) 在每组数据后面增加n位冗余码供差错检测 帧检验序列FCS(Frame Check Sequence) CRC是一种检错方法，而FSC是添加在数据后面的冗余码，在检错方法上可以选用CRC，但也可以不选用CRC 数据链路层若仅仅使用CRC差错检测技术，则只能做到对帧但无差错接收 传输差错 比特差错 比特在传输过程中可能会产生差错，1变0，0变1 没有比特差错 帧丢失 帧重复 帧失序 对于通信质量较差但无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务 点对点协议PPP(Point -to-Point Protocol)特点 应该满足的需求 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 组成 一个将IP数据报封装到串行链路的方法。PPP既支持异步链路（无奇偶检验的8比特数据），也支持面向比特的同步链路。IP数据报在PPP帧中就是信息部分。这个信息部分长度受最大传送单元MTU限制 一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)。通信双方可以协商一些选项。在RFC 1661中定义了11种类型的LCP分组 一套网络控制协议NCP(Network Control Protocol),其中的每个协议支持不同的网络层协议，如IP、OSI的网络层、DECnet、以及AppleTalk等。 帧格式 各字段意义 首部的第一个字段和尾部的第二个字段F(Flag),规定为0x7E 首部中的字段A规定为0xFF，控制字段C规定为0x03。最初考虑以后再对这两个字段的值进行定义，但自今也没有给出。 PPP首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示网络层的控制数据。 信息字段的长度是可变的，不超过1500字节 尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS 字节填充 当PPP使用异步传输时，他把转义符定义为0x7D，并使用字节填充 把信息字段中出现的每一个0x7E字节转变为2字节序列(0x7D,0x5E) 若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合），则把0x7D转变为2字节序列(0x7D,0x5D) 若信息字段中出现ASCII码的控制符（即树枝小于0x20的字符），则在字符前面加上一个0x7D字节，同时把该字符的编码加以改变。例如，出现0x03就把它转变为2字节序列(0x7D,0x23) 零比特填充 PPP协议用在SONET/SDH链路时，使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送） 在发送端，先扫描整个信息字段（通常用硬件实现，但也是可用软件实现，只是会慢些）。只要发现有5个连续1，则立即填入一个0.因此经过这个零比特填充后的数据，就可以保证在信息字段不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的0删除，以还原成原来的信息比特流 工作状态 当用户拨号接入ISP后，就建立一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组以及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一些临时的IP地址。这样，用户个人电脑就称为互联网上的一个有IP地址的主机了 使用广播信道的数据链路层局域网的数据链路层 局域网的优点 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源 便于系统的扩展和逐渐演变，各设备的位置可灵活调节和改变 提高了系统的可靠性、可用性和生存性 局域网按网络拓扑分类 星形网 环形网 总线网 共享信道技术上的两种方法 静态划分信道 频分复用、时分复用、波分复用和码分复用等，用户只要分配到了信道就不会和其他用户发送冲突。但这种方法代价较高，不适合局域网使用 动态媒体接入控制 随机接入 随机接入的特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多但用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发送了冲突），使得这些用户但发送都失败。因此，必须有解决碰撞的网络协议。 受控接入 受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling），或称为轮询。 IEEE802委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制（LLC）子层（与传输媒体无关）和媒体接入控制子层（MAC）子层（与传输媒体有关）。但现在LLC子层已成历史。MAC（Medium Access Control）LLC（Logical Link Control） 计算机与外界局域网的通信要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的ROM中 CSMA/CD协议 协议要点 多点接入 说明这是总线型网络，许多计算机以多点接入的方式连接在一个总线上 载波监听 载波监听就是检测信道。不管发送前，还是发送中，每个站都必须不停地检测信道 碰撞检测 就是“便发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据 总结 准备发送 适配器从网络层获得一个分组，加上以太网的首部和尾部，以组成以太网帧，放入适配器的缓存中。但是发送之前，必须先检测信道 检测信道 若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。 在发送过程中仍不停地检测信道，即网络适配器要边发送边监听 发送成功：争用期内一直为检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到准备发送的状态。 发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着执行指数退避算法，等待r倍512比特时间后，返回到检测信道。但若重传达16次仍不成功，则停止重传而向上报错 集线器 使用集线器物理上是星型网实际，在逻辑上仍然是一个总线网，各站使用的还是CSMA/CD协议 集线器有很多接口，很像一个多接口的转发器 集线器工作在物理层，工作只是简单地转发，不进行碰撞检测 集线器采用了专门的芯片，进行自适应串音回波抵消 以太网的MAC层（medium access control） MAC层的硬件地址 硬件地址又称为物理地址或MAC地址 MAC地址固化在适配器的ROM中 MAC帧的格式 第一个字段：6字节长的目的地址 第二个字段：6字节长的源地址 第三个字段：2字节长的类型字段 IP数据报：0x0800 Novell IPX：0x8137 第四个字段：长度在46到1500字节之间的数据字段 第五个字段：4字节的帧检验序列FCS（使用CRC检验） 扩展的以太网 使用集线器在物理层扩展以太网 交换式集线器常称为以太网交换机或第二层交换机（工作在数据链路层）。他就是一个多接口的网桥，而每个接口都直接与某台主机或另一个集线器相连，且工作在全双工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据 XMind: ZEN - Trial Version","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}]},{"title":"我的博客诞生了","slug":"my-first-blog","date":"2020-03-05T06:00:00.000Z","updated":"2020-07-25T09:23:47.738Z","comments":true,"path":"2020/ckfdz0o5i0020ai9k6culcved/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o5i0020ai9k6culcved/","excerpt":"","text":"环境配置 macbook pro 2019 前期准备下载并安装 git node.js tips：如果下载速度过慢，可以找下国内镜像仓库npm的国内镜像https://npm.taobao.org/mirrors/上面这个网址里也有git的资源 安装hexo$ npm install -g hexo-cli github仓库建立仓库名必须满足：&lt;用户名&gt;.github.io github pages部署 安装hexo-deployer-gitnpm install hexo-deployer-git 修改配置文件_config.yml1234delpoy: type: git repo: https:github.com&#x2F;&lt;用户名&gt;&#x2F;&lt;用户名&gt;.github.io branch:gh-pages 运行hexo clean &amp;&amp; hexo deploy 查看你的github网站是否更改","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shen-yu.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"实践记录","slug":"实践记录","permalink":"https://shen-yu.gitee.io/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-03T06:00:00.000Z","updated":"2020-07-25T09:22:03.544Z","comments":true,"path":"2020/ckfdz0o58001aai9kfke550q0/","link":"","permalink":"https://shen-yu.gitee.io/2020/ckfdz0o58001aai9kfke550q0/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shen-yu.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"实践记录","slug":"实践记录","permalink":"https://shen-yu.gitee.io/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"游戏引擎架构","slug":"游戏引擎架构","permalink":"https://shen-yu.gitee.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shen-yu.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"unigine引擎","slug":"unigine引擎","permalink":"https://shen-yu.gitee.io/categories/unigine%E5%BC%95%E6%93%8E/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://shen-yu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://shen-yu.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"招聘","slug":"招聘","permalink":"https://shen-yu.gitee.io/categories/%E6%8B%9B%E8%81%98/"},{"name":"c++","slug":"c","permalink":"https://shen-yu.gitee.io/categories/c/"},{"name":"java","slug":"java","permalink":"https://shen-yu.gitee.io/categories/java/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://shen-yu.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"矩阵运算","slug":"矩阵运算","permalink":"https://shen-yu.gitee.io/tags/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"},{"name":"UDP","slug":"UDP","permalink":"https://shen-yu.gitee.io/tags/UDP/"},{"name":"进程通信","slug":"进程通信","permalink":"https://shen-yu.gitee.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"containers","slug":"containers","permalink":"https://shen-yu.gitee.io/tags/containers/"},{"name":"ui","slug":"ui","permalink":"https://shen-yu.gitee.io/tags/ui/"},{"name":"数学基础","slug":"数学基础","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://shen-yu.gitee.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://shen-yu.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"面试","slug":"面试","permalink":"https://shen-yu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"笔试","slug":"笔试","permalink":"https://shen-yu.gitee.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"学习总结","slug":"学习总结","permalink":"https://shen-yu.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"实践记录","slug":"实践记录","permalink":"https://shen-yu.gitee.io/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]}